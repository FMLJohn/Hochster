import Mathlib.Topology.ClusterPt
import Mathlib.Topology.Spectral.Basic

import Hochster.SpectralSpace

open TopologicalSpace.IsTopologicalBasis TopologicalSpace Topology

/--
The constructible topology on a topological space `X` is generated by the constructible subsets of
`X`.
-/
def ConstructibleTop (X : Type*) [TopologicalSpace X] := X

section ConstructibleTop

variable (X : Type*) [TopologicalSpace X]

namespace ConstructibleTop

def toConstructibleTop : X ≃ ConstructibleTop X where
  toFun := id
  invFun := id
  left_inv _ := rfl
  right_inv _ := rfl

def ofConstructibleTop : ConstructibleTop X ≃ X where
  toFun := id
  invFun := id
  left_inv _ := rfl
  right_inv _ := rfl

instance : TopologicalSpace (ConstructibleTop X) :=
  generateFrom { s : Set X | IsConstructible s }

end ConstructibleTop

variable {X}

lemma Ultrafilter.sInter_ne_empty_of_isClosed_mem [CompactSpace X] (F : Ultrafilter X) :
    ⋂₀ { s : Set X | IsClosed s ∧ s ∈ F } ≠ ∅ := by
  intro h
  let t : { s : Set X | IsClosed s ∧ s ∈ F } → Set X := fun i => i.1
  have := isCompact_iff_finite_subfamily_closed.1 CompactSpace.isCompact_univ t (fun i => i.2.1)
  simp only [Set.univ_inter] at this
  obtain ⟨u, hu⟩ := this (Set.sInter_eq_iInter.symm.trans h)
  exact empty_not_mem <| hu ▸ (Filter.biInter_finset_mem u).2 fun i _ => i.2.2

lemma Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem
    {F : Filter X} [F.NeBot] {s : Set X} (hs : IsCompact s) (hsF : s ∈ F) :
    (s ∩ ⋂₀ { s : Set X | IsClosed s ∧ s ∈ F }).Nonempty := by
  refine Set.inter_nonempty.2 ?_
  · obtain ⟨x, hxs, hxF⟩ := IsCompact.exists_clusterPt hs (le_principal_iff.2 hsF)
    use x
    refine ⟨hxs, ?_⟩
    · simp only [Set.mem_sInter, Set.mem_setOf_eq, and_imp]
      intro t ht htF
      exact IsClosed.closure_eq ht ▸ clusterPt_iff_forall_mem_closure.1 hxF t htF

lemma exist_isClosed_union_isClosed_of_isClosed_not_isPreirreducible
    {s : Set X} (hs1 : IsClosed s) (hs2 : ¬IsPreirreducible s) :
    ∃ t u : Set X, IsClosed t ∧ IsClosed u ∧ s = t ∪ u ∧ s ≠ t ∧ s ≠ u := by
  simp [isPreirreducible_iff_isClosed_union_isClosed] at hs2
  obtain ⟨t', ht', u', hu', hstu', hst', hsu'⟩ := hs2
  use t' ∩ s; use u' ∩ s
  exact ⟨IsClosed.inter ht' hs1, IsClosed.inter hu' hs1,
    (Set.inter_eq_self_of_subset_right hstu').symm.trans (Set.union_inter_distrib_right t' u' s),
    fun h => hst' <| Set.right_eq_inter.1 h, fun h => hsu' <| Set.right_eq_inter.1 h⟩

lemma Ultrafilter.sInter_isIrreducible_of_isClosed_mem
    [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] (F : Ultrafilter X) :
    IsIrreducible (⋂₀ { s : Set X | IsClosed s ∧ s ∈ F }) := by
  refine ⟨Set.nonempty_iff_ne_empty.2 <| sInter_ne_empty_of_isClosed_mem F, ?_⟩
  · by_contra h
    obtain ⟨t, u, ht1, hu1, htu, ht2, hu2⟩ :=
      exist_isClosed_union_isClosed_of_isClosed_not_isPreirreducible
        (isClosed_sInter fun _ h => h.1) h
    by_cases h1 : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ tᶜ) → o ∉ F
    · have : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ tᶜ) → o ⊆ uᶜ := by
        intro o ho
        exact Set.subset_compl_comm.1 <| (htu ▸ Set.subset_union_right).trans <|
          Set.sInter_subset_of_mem ⟨isClosed_compl_iff.mpr ho.1,
            (or_iff_not_imp_left.1 <| mem_or_compl_mem F o) (h1 o ho)⟩
      have : tᶜ ⊆ uᶜ := by
        refine IsTopologicalBasis.subset_of_forall_subset PrespectralSpace.isTopologicalBasis
          ht1.isOpen_compl ?_
        · intro o ⟨ho1, ho2⟩ hot
          exact this o ⟨ho1, ho2, hot⟩
      exact ht2 <| htu.trans <| Set.union_eq_self_of_subset_right <| Set.compl_subset_compl.mp this
    · by_cases h2 : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ uᶜ) → o ∉ F
      · have : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ uᶜ) → o ⊆ tᶜ := by
          intro o ho
          exact Set.subset_compl_comm.1 <| (htu ▸ Set.subset_union_left).trans <|
            Set.sInter_subset_of_mem ⟨isClosed_compl_iff.mpr ho.1,
              (or_iff_not_imp_left.1 <| mem_or_compl_mem F o) (h2 o ho)⟩
        have : uᶜ ⊆ tᶜ := by
          refine IsTopologicalBasis.subset_of_forall_subset PrespectralSpace.isTopologicalBasis
            hu1.isOpen_compl ?_
          · intro o ⟨ho1, ho2⟩ hou
            exact this o ⟨ho1, ho2, hou⟩
        exact hu2 <| htu.trans <| Set.union_eq_self_of_subset_left <| Set.compl_subset_compl.mp this
      · simp only [and_imp, not_forall, not_not] at h1 h2
        obtain ⟨o, ho1, ho2, hot, hoF⟩ := h1
        obtain ⟨p, hp1, hp2, hpu, hpF⟩ := h2
        have : o ∩ p ∩ ⋂₀ {s | IsClosed s ∧ s ∈ F} = ∅ := by
          have : p ∩ ⋂₀ {s | IsClosed s ∧ s ∈ F} ⊆ t := by
            intro x ⟨hxp, hx⟩
            apply or_iff_not_imp_right.1 <| htu ▸ hx
            exact hpu hxp
          exact Set.subset_eq_empty
            (Set.inter_assoc _ _ _ ▸ (Set.inter_subset_inter Set.Subset.rfl this)) <|
              Disjoint.inter_eq <| Set.subset_compl_iff_disjoint_right.1 hot
        exact Set.Nonempty.ne_empty
          (Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem
            (QuasiSeparatedSpace.inter_isCompact o p ho1 ho2 hp1 hp2)
              (Filter.inter_mem hoF hpF)) this

lemma singleton_closure_inter_open_nonempty_iff (x : X) {o : Set X} (ho : IsOpen o) :
    (closure {x} ∩ o).Nonempty ↔ x ∈ o :=
  (closure_inter_open_nonempty_iff ho).trans Set.singleton_inter_nonempty

namespace ConstructibleTop

variable (X) in
lemma compactSpace_of_spectralSpace [SpectralSpace X] : CompactSpace (ConstructibleTop X) := by
  delta instTopologicalSpace
  rw [@generateFrom_isConstructible_eq_generateFrom_union_compl_image X, ← @isCompact_univ_iff,
    @isCompact_iff_ultrafilter_le_nhds']
  intro F _
  by_contra h
  have h1 : ∀ x : X, ∃ t, x ∈ t ∧ t ∈ { s : Set X | IsOpen s ∧ IsCompact s } ∪
      compl '' { s : Set X | IsOpen s ∧ IsCompact s } ∧ t ∉ F := by
    simpa [nhds_generateFrom] using h
  obtain ⟨x, hx⟩ := @QuasiSober.sober X _ _ _
    (@Ultrafilter.sInter_isIrreducible_of_isClosed_mem X _ _ _ _ F)
    (isClosed_sInter fun _ h => h.1)
  have h2 : ∀ t ∈ { s | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s },
      x ∈ t → t ∈ F := by
    intro t ht hxt
    by_contra htF
    refine Or.elim ht ?_ ?_
    · rintro ⟨ht1, ht2⟩
      exact ((Set.sInter_subset_of_mem (Set.mem_sep (isClosed_compl_iff.mpr ht1)
        (Ultrafilter.compl_mem_iff_not_mem.mpr htF))) (IsGenericPoint.mem hx)) hxt
    · rintro ⟨o, ⟨ho1, ho2⟩, hot⟩
      exact (hot ▸ hxt) ((singleton_closure_inter_open_nonempty_iff x ho1).1
        (Set.inter_comm _ _ ▸ hx ▸ Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem ho2
          (Ultrafilter.compl_not_mem_iff.mp (hot ▸ htF))))
  obtain ⟨t, hxt, ht, htF⟩ := h1 x
  exact htF (h2 t ht hxt)

end ConstructibleTop

end ConstructibleTop

lemma TopologicalSpace.subbasis_iff_isTopologicalBasis_sInter
    {X : Type*} [T : TopologicalSpace X] (S : Set (Set X)) :
    T = generateFrom S ↔
    IsTopologicalBasis ((fun F => ⋂₀ F) '' { F : Set (Set X) | F.Finite ∧ F ⊆ S }) := by
  refine ⟨isTopologicalBasis_of_subbasis, fun h => h.eq_generateFrom ▸ eq_of_le_of_le ?_ ?_⟩
  · exact le_generateFrom fun s hsS =>
      isOpen_generateFrom_of_mem
        ⟨{s}, ⟨Set.finite_singleton s, Set.singleton_subset_iff.mpr hsS⟩, Set.sInter_singleton s⟩
  · exact le_generateFrom fun s ⟨F, ⟨hF, hFS⟩, hFs⟩ =>
      hFs ▸ @Set.Finite.isOpen_sInter _ (generateFrom S) _ hF fun t htF =>
        isOpen_generateFrom_of_mem (hFS htF)

lemma SpectralSpace.exists_of_isOpen_isCompact_isEmbedding {X Y : Type*}
    [TopologicalSpace X] [SpectralSpace X] [TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) {s : Set X} (hs1 : IsOpen s) (hs2 : IsCompact s) :
    ∃ o : Set Y, IsOpen o ∧ IsCompact o ∧ s = f ⁻¹' o := by
  let ι := Set.preimage f '' { s | IsOpen s ∧ IsCompact s }
  obtain ⟨S, hS, hsS⟩ := eq_finite_iUnion_of_isTopologicalBasis_of_isCompact_open (fun i : ι => i.1)
    (by simpa using hf.eq_induced ▸ PrespectralSpace.isTopologicalBasis.induced f) s hs2 hs1
  have : ∀ t ∈ ι, ∃ u : Set Y, IsOpen u ∧ IsCompact u ∧ t = f ⁻¹' u :=
    fun t ⟨u, ⟨hu1, hu2⟩, hfut⟩ => ⟨u, hu1, hu2, hfut.symm⟩
  choose! U hU1 hU2 hU3 using this
  exact ⟨⋃ t ∈ S, U t.1, isOpen_biUnion fun t htS => hU1 t t.2,
    Set.Finite.isCompact_biUnion hS fun t htS => hU2 t t.2,
    hsS ▸ Set.biUnion_eq_iUnion _ _ ▸ Set.biUnion_eq_iUnion _ _ ▸
      Set.preimage_iUnion (f := f) ▸ Set.iUnion_congr fun t => hU3 t.1 t.1.2⟩

namespace ConstructibleTop

lemma instTopologicalSpace_le (X : Type*) [T : TopologicalSpace X]
    [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] :
    instTopologicalSpace X ≤ T := by
  rw [instTopologicalSpace, generateFrom_isConstructible_eq_generateFrom_union_compl_image X]
  exact PrespectralSpace.isTopologicalBasis (X := X).eq_generateFrom ▸
    le_generateFrom fun s hs => isOpen_generateFrom_of_mem <|
      PrespectralSpace.isTopologicalBasis (X := X).eq_generateFrom ▸ Or.intro_left _ hs

lemma instTopologicalSpace_eq_induced_of_isEmbedding_isSpectralMap {X Y : Type*}
    [TopologicalSpace X] [SpectralSpace X] [TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf1 : IsEmbedding f) (hf2 : IsSpectralMap f) :
    instTopologicalSpace X = induced f (instTopologicalSpace Y) := by
  unfold instTopologicalSpace
  rw [generateFrom_isConstructible_eq_generateFrom_union_compl_image X,
    generateFrom_isConstructible_eq_generateFrom_union_compl_image Y, induced_generateFrom_eq]
  refine eq_of_le_of_le (le_generateFrom fun s ⟨t, ht, hts⟩ => ?_) (le_generateFrom fun s hs => ?_)
  · refine Or.elim ht (fun ⟨ht1, ht2⟩ => ?_) (fun ⟨u, ⟨hu1, hu2⟩, hut⟩ => ?_)
    · exact hts ▸ generateFrom_isConstructible_eq_generateFrom_union_compl_image X ▸
        (TopologicalSpace.le_def.1 <| instTopologicalSpace_le X) _
          (IsOpen.preimage hf1.continuous ht1)
    · exact hts ▸ hut ▸ (isOpen_generateFrom_of_mem <|
        Or.intro_right _ ⟨f ⁻¹' u, ⟨IsOpen.preimage hf1.continuous hu1,
          hf2.isCompact_preimage_of_isOpen hu1 hu2⟩, rfl⟩)
  · refine isOpen_generateFrom_of_mem <| Or.elim hs ?_ ?_
    · intro ⟨hs1, hs2⟩
      obtain ⟨o, ho1, ho2, hsfo⟩ := SpectralSpace.exists_of_isOpen_isCompact_isEmbedding hf1 hs1 hs2
      exact ⟨o, Or.intro_left _ ⟨ho1, ho2⟩, hsfo.symm⟩
    · intro ⟨o, ⟨ho1, ho2⟩, hos⟩
      obtain ⟨t, ht1, ht2, hoft⟩ := SpectralSpace.exists_of_isOpen_isCompact_isEmbedding hf1 ho1 ho2
      exact ⟨tᶜ, Or.intro_right _ ⟨t, ⟨ht1, ht2⟩, rfl⟩, Set.preimage_compl.symm ▸ hoft ▸ hos⟩

end ConstructibleTop
