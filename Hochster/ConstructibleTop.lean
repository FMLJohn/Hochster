import Mathlib.Topology.ClusterPt
import Mathlib.Topology.Spectral.Basic

import Hochster.SpectralSpace

open TopologicalSpace Topology

/--
The constructible topology on a topological space `X` is generated by the constructible subsets of
`X`.
-/
def ConstructibleTop (X : Type*) [TopologicalSpace X] := X

variable (X : Type*) [TopologicalSpace X]

namespace ConstructibleTop

def toConstructibleTop : X ≃ ConstructibleTop X where
  toFun := id
  invFun := id
  left_inv _ := rfl
  right_inv _ := rfl

def ofConstructibleTop : ConstructibleTop X ≃ X where
  toFun := id
  invFun := id
  left_inv _ := rfl
  right_inv _ := rfl

instance : TopologicalSpace (ConstructibleTop X) :=
  generateFrom { s : Set X | IsConstructible s }

end ConstructibleTop

variable {X}

lemma Ultrafilter.sInter_ne_empty_of_isClosed_mem [CompactSpace X] (F : Ultrafilter X) :
    ⋂₀ { s : Set X | IsClosed s ∧ s ∈ F } ≠ ∅ := by
  intro h
  let t : { s : Set X | IsClosed s ∧ s ∈ F } → Set X := fun i => i.1
  have := isCompact_iff_finite_subfamily_closed.1 CompactSpace.isCompact_univ t (fun i => i.2.1)
  simp only [Set.univ_inter] at this
  obtain ⟨u, hu⟩ := this (Set.sInter_eq_iInter.symm.trans h)
  exact empty_not_mem <| hu ▸ (Filter.biInter_finset_mem u).2 fun i _ => i.2.2

lemma Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem
    {F : Filter X} [F.NeBot] {s : Set X} (hs : IsCompact s) (hsF : s ∈ F) :
    (s ∩ ⋂₀ { s : Set X | IsClosed s ∧ s ∈ F }).Nonempty := by
  refine Set.inter_nonempty.2 ?_
  · obtain ⟨x, hxs, hxF⟩ := IsCompact.exists_clusterPt hs (le_principal_iff.2 hsF)
    use x
    refine ⟨hxs, ?_⟩
    · simp only [Set.mem_sInter, Set.mem_setOf_eq, and_imp]
      intro t ht htF
      exact IsClosed.closure_eq ht ▸ clusterPt_iff_forall_mem_closure.1 hxF t htF

lemma exist_isClosed_union_isClosed_of_isClosed_not_isPreirreducible
    {s : Set X} (hs1 : IsClosed s) (hs2 : ¬IsPreirreducible s) :
    ∃ t u : Set X, IsClosed t ∧ IsClosed u ∧ s = t ∪ u ∧ s ≠ t ∧ s ≠ u := by
  simp [isPreirreducible_iff_isClosed_union_isClosed] at hs2
  obtain ⟨t', ht', u', hu', hstu', hst', hsu'⟩ := hs2
  use t' ∩ s; use u' ∩ s
  exact ⟨IsClosed.inter ht' hs1, IsClosed.inter hu' hs1,
    (Set.inter_eq_self_of_subset_right hstu').symm.trans (Set.union_inter_distrib_right t' u' s),
    fun h => hst' <| Set.right_eq_inter.1 h, fun h => hsu' <| Set.right_eq_inter.1 h⟩

lemma Ultrafilter.sInter_isIrreducible_of_isClosed_mem
    [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] (F : Ultrafilter X) :
    IsIrreducible (⋂₀ { s : Set X | IsClosed s ∧ s ∈ F }) := by
  refine ⟨Set.nonempty_iff_ne_empty.2 <| sInter_ne_empty_of_isClosed_mem F, ?_⟩
  · by_contra h
    obtain ⟨t, u, ht1, hu1, htu, ht2, hu2⟩ :=
      exist_isClosed_union_isClosed_of_isClosed_not_isPreirreducible
        (isClosed_sInter fun _ h => h.1) h
    by_cases h1 : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ tᶜ) → o ∉ F
    · have : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ tᶜ) → o ⊆ uᶜ := by
        intro o ho
        exact Set.subset_compl_comm.1 <| (htu ▸ Set.subset_union_right).trans <|
          Set.sInter_subset_of_mem ⟨isClosed_compl_iff.mpr ho.1,
            (or_iff_not_imp_left.1 <| mem_or_compl_mem F o) (h1 o ho)⟩
      have : tᶜ ⊆ uᶜ := by
        refine IsTopologicalBasis.subset_of_forall_subset PrespectralSpace.isTopologicalBasis
          ht1.isOpen_compl ?_
        · intro o ⟨ho1, ho2⟩ hot
          exact this o ⟨ho1, ho2, hot⟩
      exact ht2 <| htu.trans <| Set.union_eq_self_of_subset_right <| Set.compl_subset_compl.mp this
    · by_cases h2 : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ uᶜ) → o ∉ F
      · have : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ uᶜ) → o ⊆ tᶜ := by
          intro o ho
          exact Set.subset_compl_comm.1 <| (htu ▸ Set.subset_union_left).trans <|
            Set.sInter_subset_of_mem ⟨isClosed_compl_iff.mpr ho.1,
              (or_iff_not_imp_left.1 <| mem_or_compl_mem F o) (h2 o ho)⟩
        have : uᶜ ⊆ tᶜ := by
          refine IsTopologicalBasis.subset_of_forall_subset PrespectralSpace.isTopologicalBasis
            hu1.isOpen_compl ?_
          · intro o ⟨ho1, ho2⟩ hou
            exact this o ⟨ho1, ho2, hou⟩
        exact hu2 <| htu.trans <| Set.union_eq_self_of_subset_left <| Set.compl_subset_compl.mp this
      · simp only [and_imp, not_forall, not_not] at h1 h2
        obtain ⟨o, ho1, ho2, hot, hoF⟩ := h1
        obtain ⟨p, hp1, hp2, hpu, hpF⟩ := h2
        have : o ∩ p ∩ ⋂₀ {s | IsClosed s ∧ s ∈ F} = ∅ := by
          have : p ∩ ⋂₀ {s | IsClosed s ∧ s ∈ F} ⊆ t := by
            intro x ⟨hxp, hx⟩
            apply or_iff_not_imp_right.1 <| htu ▸ hx
            exact hpu hxp
          exact Set.subset_eq_empty
            (Set.inter_assoc _ _ _ ▸ (Set.inter_subset_inter Set.Subset.rfl this)) <|
              Disjoint.inter_eq <| Set.subset_compl_iff_disjoint_right.1 hot
        exact Set.Nonempty.ne_empty
          (Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem
            (QuasiSeparatedSpace.inter_isCompact o p ho1 ho2 hp1 hp2)
              (Filter.inter_mem hoF hpF)) this

lemma singleton_closure_inter_open_nonempty_iff (x : X) {o : Set X} (ho : IsOpen o) :
    (closure {x} ∩ o).Nonempty ↔ x ∈ o :=
  (closure_inter_open_nonempty_iff ho).trans Set.singleton_inter_nonempty

namespace ConstructibleTop

variable (X) in
lemma compactSpace_of_spectralSpace [SpectralSpace X] : CompactSpace (ConstructibleTop X) := by
  delta instTopologicalSpace
  rw [@generateFrom_isConstructible_eq_generateFrom_union_compl_image X, ← @isCompact_univ_iff,
    @isCompact_iff_ultrafilter_le_nhds']
  intro F _
  by_contra h
  have h1 : ∀ x : X, ∃ t, x ∈ t ∧ t ∈ { s : Set X | IsOpen s ∧ IsCompact s } ∪
      compl '' { s : Set X | IsOpen s ∧ IsCompact s } ∧ t ∉ F := by
    simpa [nhds_generateFrom] using h
  obtain ⟨x, hx⟩ := @QuasiSober.sober X _ _ _
    (@Ultrafilter.sInter_isIrreducible_of_isClosed_mem X _ _ _ _ F)
    (isClosed_sInter fun _ h => h.1)
  have h2 : ∀ t ∈ { s | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s },
      x ∈ t → t ∈ F := by
    intro t ht hxt
    by_contra htF
    refine Or.elim ht ?_ ?_
    · rintro ⟨ht1, ht2⟩
      exact ((Set.sInter_subset_of_mem (Set.mem_sep (isClosed_compl_iff.mpr ht1)
        (Ultrafilter.compl_mem_iff_not_mem.mpr htF))) (IsGenericPoint.mem hx)) hxt
    · rintro ⟨o, ⟨ho1, ho2⟩, hot⟩
      exact (hot ▸ hxt) ((singleton_closure_inter_open_nonempty_iff x ho1).1
        (Set.inter_comm _ _ ▸ hx ▸ Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem ho2
          (Ultrafilter.compl_not_mem_iff.mp (hot ▸ htF))))
  obtain ⟨t, hxt, ht, htF⟩ := h1 x
  exact htF (h2 t ht hxt)

lemma wewefwef (Y : Set X) [SpectralSpace Y] :
    instTopologicalSpace Y =
    @instTopologicalSpaceSubtype (ConstructibleTop X) _ _ := by
  unfold instTopologicalSpace
  rw [@generateFrom_isConstructible_eq_generateFrom_union_compl_image Y]
  sorry

end ConstructibleTop
