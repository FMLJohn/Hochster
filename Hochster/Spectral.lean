import Mathlib.Topology.Spectral.Basic

import Hochster.FiniteIntersection

open FiniteInterClosedSubbasisSet TopologicalSpace Topology

variable (X : Type*) [T : TopologicalSpace X]

/--
The patch topology on a topological space `X` is generated by the open compact subsets of `X` and
the complements of them.
-/
def PatchTopology : TopologicalSpace X :=
  generateFrom ({ S : Set X | IsOpen S ∧ IsCompact S } ∪
    { S : Set X | ∃ O : Set X, IsOpen O ∧ IsCompact O ∧ S = Oᶜ })

lemma PatchTopology_eq_generateFrom_of_SpectralSpace [spectral : SpectralSpace X] :
    PatchTopology X = generateFrom
      { S : Set X | ∃ C : Set X, (IsClosed C ∨ IsOpen C ∧ IsCompact C) ∧ Cᶜ = S } := by
  refine eq_of_le_of_le ?_ ?_
  · refine le_generateFrom_iff_subset_isOpen.2 ?_
    · simp only [Set.setOf_subset_setOf, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]
      intro S hS
      refine Or.elim hS ?_ ?_
      · have le : generateFrom ({ S : Set X | IsOpen S ∧ IsCompact S} ∪
            { S : Set X | ∃ O : Set X, IsOpen O ∧ IsCompact O ∧ S = Oᶜ }) ≤ T := by
          rw [spectral.isTopologicalBasis.eq_generateFrom]
          refine le_generateFrom_iff_subset_isOpen.2 ?_
          · simp only [Set.setOf_subset_setOf, and_imp,
              ← spectral.isTopologicalBasis.eq_generateFrom]
            intro S hS1 hS2
            exact isOpen_generateFrom_of_mem <| Or.intro_left _ ⟨hS1, hS2⟩
        exact fun _ => le Sᶜ IsClosed.isOpen_compl
      · rintro ⟨hS1, hS2⟩
        refine isOpen_generateFrom_of_mem ?_
        · simp only [Set.mem_union, Set.mem_setOf_eq, compl_inj_iff, exists_eq_right_right']
          exact Or.intro_right _ ⟨hS1, hS2⟩
  · refine le_generateFrom_iff_subset_isOpen.2 ?_
    · intro S hS
      refine Or.elim hS ?_ ?_
      · rintro ⟨hS1, hS2⟩
        exact isOpen_generateFrom_of_mem ⟨Sᶜ, Or.intro_left _ <| isClosed_compl_iff.mpr hS1,
          compl_compl S⟩
      · rintro ⟨O, hO1, hO2, hO3⟩
        exact isOpen_generateFrom_of_mem ⟨O, Or.intro_right _ ⟨hO1, hO2⟩, hO3.symm⟩

lemma wef [Nonempty X] [SpectralSpace X] : @CompactSpace X (PatchTopology X) := by
  let ι := { S : Set X | IsClosed S } ∪ { S : Set X | IsOpen S ∧ IsCompact S }
  let V := fun i : ι => i.1
  have eq : PatchTopology X = generateFrom { (V i)ᶜ | i : ι } := by
    unfold ι V
    simp only [Subtype.exists, Set.mem_union, Set.mem_setOf_eq, exists_prop]
    exact PatchTopology_eq_generateFrom_of_SpectralSpace X
  rw [@CompactSpace_iff_forall_isMax_neq X ι (PatchTopology X) V eq]
  intro U hU empty
  sorry
