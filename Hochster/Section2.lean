import Mathlib.Data.Set.Operations
import Mathlib.Topology.Constructible
import Mathlib.Topology.Spectral.Basic

open Classical TopologicalSpace.IsTopologicalBasis TopologicalSpace Topology

section BasicsOfConstructibleTop

/--
Let `X` be a topological space and suppose `S : Set (Set X)`, `TopologicalSpace.isClosedSubbasis S`
means that the topology on `X` equals `generateFrom { sᶜ | s ∈ S }`.
-/
def TopologicalSpace.isClosedSubbasis
    {X : Type*} [T : TopologicalSpace X] (S : Set (Set X)) :=
  T = generateFrom (compl '' S)

lemma TopologicalSpace.subbasis_iff_isTopologicalBasis_sInter
    {X : Type*} [T : TopologicalSpace X] (S : Set (Set X)) :
    T = generateFrom S ↔
    IsTopologicalBasis ((fun F => ⋂₀ F) '' { F : Set (Set X) | F.Finite ∧ F ⊆ S }) := by
  refine ⟨isTopologicalBasis_of_subbasis, fun h => h.eq_generateFrom ▸ eq_of_le_of_le ?_ ?_⟩
  · exact le_generateFrom fun s hsS =>
      isOpen_generateFrom_of_mem
        ⟨{s}, ⟨Set.finite_singleton s, Set.singleton_subset_iff.mpr hsS⟩, Set.sInter_singleton s⟩
  · exact le_generateFrom fun s ⟨F, ⟨hF, hFS⟩, hFs⟩ =>
      hFs ▸ @Set.Finite.isOpen_sInter _ (generateFrom S) _ hF fun t htF =>
        isOpen_generateFrom_of_mem (hFS htF)

lemma TopologicalSpace.isClosedSubbasis_iff_isTopologicalBasis_sInter_compl
    {X : Type*} [T : TopologicalSpace X] (S : Set (Set X)) :
    isClosedSubbasis S ↔
    IsTopologicalBasis ((fun F => ⋂₀ F) '' { F : Set (Set X) | F.Finite ∧ F ⊆ compl '' S }) :=
  subbasis_iff_isTopologicalBasis_sInter (compl '' S)

/--
The constructible topology on a topological space `X` is generated by the constructible subsets of
`X`.
-/
def ConstructibleTop (X : Type*) [TopologicalSpace X] := X

namespace ConstructibleTop

def toConstructibleTop (X : Type*) [TopologicalSpace X] :
    X ≃ ConstructibleTop X where
  toFun := id
  invFun := id
  left_inv _ := rfl
  right_inv _ := rfl

def ofConstructibleTop (X : Type*) [TopologicalSpace X] :
    ConstructibleTop X ≃ X where
  toFun := id
  invFun := id
  left_inv _ := rfl
  right_inv _ := rfl

instance (X : Type*) [TopologicalSpace X] :
    TopologicalSpace (ConstructibleTop X) :=
  generateFrom { s : Set X | IsConstructible s }

end ConstructibleTop

theorem latticeClosure.sup_inf_induction {α : Type*} [Lattice α]
    {s : Set α} (p : (a : α) → a ∈ latticeClosure s → Prop)
    (mem : ∀ (a : α) (has : a ∈ s), p a (subset_latticeClosure has))
    (sup : ∀ (a : α) (has : a ∈ latticeClosure s) (b : α) (hbs : b ∈ latticeClosure s),
      p a has → p b hbs → p (a ⊔ b) (IsSublattice.supClosed isSublattice_latticeClosure has hbs))
    (inf : ∀ (a : α) (has : a ∈ latticeClosure s) (b : α) (hbs : b ∈ latticeClosure s),
      p a has → p b hbs → p (a ⊓ b) (IsSublattice.infClosed isSublattice_latticeClosure has hbs))
    {a : α} (has : a ∈ latticeClosure s) :
    p a has := by
  have h1 : s ⊆ { a : α | ∃ has : a ∈ latticeClosure s, p a has } :=
    fun a ha ↦ ⟨subset_latticeClosure ha, mem a ha⟩
  have h2 : IsSublattice { a : α | ∃ has : a ∈ latticeClosure s, p a has } := {
    supClosed := fun a ⟨has, hpa⟩ b ⟨hbs, hpb⟩ =>
      ⟨IsSublattice.supClosed isSublattice_latticeClosure has hbs, sup a has b hbs hpa hpb⟩
    infClosed := fun a ⟨has, hpa⟩ b ⟨hbs, hpb⟩ =>
      ⟨IsSublattice.infClosed isSublattice_latticeClosure has hbs, inf a has b hbs hpa hpb⟩ }
  exact (latticeClosure_min h1 h2 has).choose_spec

lemma Set.compl_image_latticeClosure {X : Type*} (S : Set (Set X)) :
    compl '' (latticeClosure S) = latticeClosure (compl '' S) := by
  refine Set.eq_of_subset_of_subset ?_ ?_
  · intro s ⟨c, hcS, hcs⟩
    refine hcs ▸ latticeClosure.sup_inf_induction (fun c hcS => cᶜ ∈ latticeClosure (compl '' S))
      ?_ ?_ ?_ hcS
    · exact fun c hcS ↦ subset_latticeClosure <| Set.mem_image_of_mem compl hcS
    · intro a _ b _ haS hbS
      exact Set.compl_union _ _ ▸ IsSublattice.infClosed isSublattice_latticeClosure haS hbS
    · intro a _ b _ haS hbS
      exact Set.compl_inter _ _ ▸ IsSublattice.supClosed isSublattice_latticeClosure haS hbS
  · refine latticeClosure_min ?_ ?_
    · exact fun s ⟨c, hcS, hcs⟩ ↦ ⟨c, subset_latticeClosure hcS, hcs⟩
    · exact {
      supClosed := fun a ⟨c, hcS, hca⟩ b ⟨d, hdS, hdb⟩ =>
        ⟨aᶜ ⊓ bᶜ, hca ▸ hdb ▸ IsSublattice.infClosed isSublattice_latticeClosure
          ((compl_compl c).symm ▸ hcS) ((compl_compl d).symm ▸ hdS),
            Set.compl_inter _ _ ▸ (compl_compl a).symm ▸ (compl_compl b).symm ▸ rfl⟩
      infClosed := fun a ⟨c, hcS, hca⟩ b ⟨d, hdS, hdb⟩ =>
        ⟨aᶜ ⊔ bᶜ, hca ▸ hdb ▸ IsSublattice.supClosed isSublattice_latticeClosure
          ((compl_compl c).symm ▸ hcS) ((compl_compl d).symm ▸ hdS),
            Set.compl_union _ _ ▸ (compl_compl a).symm ▸ (compl_compl b).symm ▸ rfl⟩ }

lemma Set.compl_image_latticeClosure_eq_of_compl_image_eq_self
    {X : Type*} {S : Set (Set X)} (hS : compl '' S = S) :
    compl '' (latticeClosure S) = latticeClosure S :=
  Set.compl_image_latticeClosure S ▸ hS.symm ▸ rfl

namespace TopologicalSpace

lemma generateFrom_latticeClosure {X : Type*} (S : Set (Set X)) :
    generateFrom (latticeClosure S) = generateFrom S := by
  refine eq_of_le_of_le ?_ ?_
  · exact le_generateFrom fun o hoS ↦ isOpen_generateFrom_of_mem <| subset_latticeClosure hoS
  · refine le_generateFrom fun o hoS ↦ ?_
    refine latticeClosure.sup_inf_induction (fun s _ => IsOpen[generateFrom S] s) ?_ ?_ ?_ hoS
    · exact fun _ h ↦ isOpen_generateFrom_of_mem h
    · exact fun _ _ _ _ h1 h2 ↦ @IsOpen.union X _ _ (generateFrom S) h1 h2
    · exact fun _ _ _ _ h1 h2 ↦ @IsOpen.inter X (generateFrom S) _ _ h1 h2

lemma generateFrom_booleanSubalgebra_closure_eq_of_isSublattice {X : Type*}
    {S : Set (Set X)} (hS1 : ⊥ ∈ S) (hS2 : compl '' S = S) (hS3 : IsSublattice S) :
    generateFrom (BooleanSubalgebra.closure S) = generateFrom S := by
  refine eq_of_le_of_le ?_ ?_
  · refine le_generateFrom fun _ h ↦ isOpen_generateFrom_of_mem <| BooleanSubalgebra.subset_closure h
  · refine le_generateFrom ?_
    · refine fun s hsS ↦ BooleanSubalgebra.closure_sdiff_sup_induction hS3 hS1 (hS2 ▸ ⟨⊥, hS1, compl_bot⟩)
        ?_ (fun _ _ _ _ h1 h2 ↦ @IsOpen.union _ _ _ (generateFrom S) h1 h2) s hsS
      exact fun s hsS t htS ↦ Set.diff_eq_compl_inter ▸ (isOpen_generateFrom_of_mem <|
        IsSublattice.infClosed hS3 (hS2 ▸ Set.mem_image_of_mem compl htS) hsS)

lemma generateFrom_booleanSubalgebra_closure
    {X : Type*} {S : Set (Set X)} (hS1 : ⊥ ∈ S) (hS2 : compl '' S = S) :
    generateFrom (BooleanSubalgebra.closure S) = generateFrom S :=
  BooleanSubalgebra.closure_latticeClosure S ▸
    generateFrom_booleanSubalgebra_closure_eq_of_isSublattice (subset_latticeClosure hS1)
      (Set.compl_image_latticeClosure_eq_of_compl_image_eq_self hS2) isSublattice_latticeClosure ▸
        generateFrom_latticeClosure S

lemma generateFrom_isConstructible_eq_generateFrom_union_compl_image
    (X : Type*) [TopologicalSpace X] [CompactSpace X] [QuasiSeparatedSpace X] :
    generateFrom { s : Set X | IsConstructible s } =
    generateFrom ({ s | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s }) := by
  have h1 : ⊥ ∈ { s : Set X | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s } :=
    Or.intro_left _ ⟨isOpen_empty, isCompact_empty⟩
  have h2 : compl '' ({ s | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s }) =
      { s : Set X | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s } :=
    (Set.image_union _ _ _).symm ▸
      (Set.compl_compl_image { s : Set X | IsOpen s ∧ IsCompact s }).symm ▸
        Set.union_comm _ _
  refine generateFrom_booleanSubalgebra_closure h1 h2 ▸ ?_
  · congr
    refine Set.eq_of_subset_of_subset (BooleanSubalgebra.closure_mono fun s ⟨hs1, hs2⟩ ↦ ?_) ?_
    · exact Or.intro_left _ ⟨hs1, (QuasiSeparatedSpace.isRetrocompact_iff_isCompact hs1).1 hs2⟩
    · intro s hs
      simp only [Set.mem_setOf_eq]
      refine BooleanSubalgebra.mem_closure.1 hs ?_
      · refine fun t ht ↦ Or.elim ht (fun ⟨ht1, ht2⟩ ↦ ?_) fun ⟨u, ⟨hu1, hu2⟩, hut⟩ ↦ ?_
        · exact BooleanSubalgebra.subset_closure ⟨ht1,
            (QuasiSeparatedSpace.isRetrocompact_iff_isCompact ht1).2 ht2⟩
        · exact hut ▸ BooleanSubalgebra.compl_mem <| BooleanSubalgebra.subset_closure
            ⟨hu1, (QuasiSeparatedSpace.isRetrocompact_iff_isCompact hu1).2 hu2⟩

end TopologicalSpace

namespace ConstructibleTop

lemma instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image
    (X : Type*) [TopologicalSpace X] [CompactSpace X] [QuasiSeparatedSpace X] :
    instTopologicalSpace X =
    generateFrom ({ s : Set X | IsOpen s ∧ IsCompact s} ∪
      compl '' { s | IsOpen s ∧ IsCompact s }) := by
  rw [instTopologicalSpace, generateFrom_isConstructible_eq_generateFrom_union_compl_image X]

lemma isClosedSubbasis_isClosed_union_isOpen_isCompact (X : Type*)
    [TopologicalSpace X] [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] :
    isClosedSubbasis (X := ConstructibleTop X)
      ({ s : Set X | IsClosed s } ∪ { s : Set X | IsOpen s ∧ IsCompact s }) := by
  change _ = generateFrom _
  have h1 : compl '' { s : Set X | IsClosed s } = { s | IsOpen s } := by
    ext s
    exact ⟨fun ⟨c, hc, hcs⟩ => hcs ▸ isOpen_compl_iff.2 hc,
      fun hs => ⟨sᶜ, isClosed_compl_iff.2 hs, compl_compl s⟩⟩
  refine instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image X ▸
    Set.image_union _ _ _ ▸ h1 ▸ eq_of_le_of_le ?_ ?_
  · refine le_generateFrom fun s hs => Or.elim hs (fun hs ↦ ?_) ?_
    · obtain ⟨F, hF, hsF⟩ := PrespectralSpace.isTopologicalBasis.open_eq_sUnion hs
      exact hsF ▸ @isOpen_sUnion X (generateFrom _) _ fun t htF => isOpen_generateFrom_of_mem <|
        Or.intro_left _ <| hF htF
    · exact fun hs ↦ isOpen_generateFrom_of_mem <| Or.intro_right _ hs
  · exact generateFrom_anti <| Set.union_subset_union_left _ fun s hs => hs.1

lemma instTopologicalSpace_le (X : Type*) [T : TopologicalSpace X]
    [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] :
    instTopologicalSpace X ≤ T := by
  rw [instTopologicalSpace, generateFrom_isConstructible_eq_generateFrom_union_compl_image X]
  exact PrespectralSpace.isTopologicalBasis (X := X).eq_generateFrom ▸
    le_generateFrom fun s hs => isOpen_generateFrom_of_mem <|
      PrespectralSpace.isTopologicalBasis (X := X).eq_generateFrom ▸ Or.intro_left _ hs

end ConstructibleTop

end BasicsOfConstructibleTop

open ConstructibleTop

section Theorem1

lemma Ultrafilter.sInter_ne_empty_of_isClosed_mem {X : Type*}
    [TopologicalSpace X] [CompactSpace X] (F : Ultrafilter X) :
    ⋂₀ { s : Set X | IsClosed s ∧ s ∈ F } ≠ ∅ := by
  intro h
  let t : { s : Set X | IsClosed s ∧ s ∈ F } → Set X := fun i => i.1
  have := isCompact_iff_finite_subfamily_closed.1 CompactSpace.isCompact_univ t (fun i => i.2.1)
  simp only [Set.univ_inter] at this
  obtain ⟨u, hu⟩ := this (Set.sInter_eq_iInter.symm.trans h)
  exact empty_notMem <| hu ▸ (Filter.biInter_finset_mem u).2 fun i _ => i.2.2

lemma Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem {X : Type*} [TopologicalSpace X]
    {F : Filter X} [F.NeBot] {s : Set X} (hs : IsCompact s) (hsF : s ∈ F) :
    (s ∩ ⋂₀ { s : Set X | IsClosed s ∧ s ∈ F }).Nonempty := by
  refine Set.inter_nonempty.2 ?_
  obtain ⟨x, hxs, hxF⟩ := IsCompact.exists_clusterPt hs (le_principal_iff.2 hsF)
  refine ⟨x, hxs, ?_⟩
  simp only [Set.mem_sInter, Set.mem_setOf_eq, and_imp]
  exact fun t ht htF ↦ IsClosed.closure_eq ht ▸ clusterPt_iff_forall_mem_closure.1 hxF t htF

lemma exist_isClosed_union_isClosed_of_isClosed_not_isPreirreducible
    {X : Type*} [TopologicalSpace X] {s : Set X} (hs1 : IsClosed s) (hs2 : ¬IsPreirreducible s) :
    ∃ t u : Set X, IsClosed t ∧ IsClosed u ∧ s = t ∪ u ∧ s ≠ t ∧ s ≠ u := by
  simp [isPreirreducible_iff_isClosed_union_isClosed] at hs2
  obtain ⟨t', ht', u', hu', hstu', hst', hsu'⟩ := hs2
  exact ⟨t' ∩ s, u' ∩ s, IsClosed.inter ht' hs1, IsClosed.inter hu' hs1,
    (Set.inter_eq_self_of_subset_right hstu').symm.trans (Set.union_inter_distrib_right t' u' s),
    fun h => hst' <| Set.right_eq_inter.1 h, fun h => hsu' <| Set.right_eq_inter.1 h⟩

lemma Ultrafilter.sInter_isIrreducible_of_isClosed_mem {X : Type*} [TopologicalSpace X]
    [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] (F : Ultrafilter X) :
    IsIrreducible (⋂₀ { s : Set X | IsClosed s ∧ s ∈ F }) := by
  refine ⟨Set.nonempty_iff_ne_empty.2 <| sInter_ne_empty_of_isClosed_mem F, ?_⟩
  · by_contra h
    obtain ⟨t, u, ht1, hu1, htu, ht2, hu2⟩ :=
      exist_isClosed_union_isClosed_of_isClosed_not_isPreirreducible
        (isClosed_sInter fun _ h => h.1) h
    by_cases h1 : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ tᶜ) → o ∉ F
    · have : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ tᶜ) → o ⊆ uᶜ := by
        intro o ho
        exact Set.subset_compl_comm.1 <| (htu ▸ Set.subset_union_right).trans <|
          Set.sInter_subset_of_mem ⟨isClosed_compl_iff.mpr ho.1,
            (or_iff_not_imp_left.1 <| mem_or_compl_mem F o) (h1 o ho)⟩
      have : tᶜ ⊆ uᶜ := by
        refine IsTopologicalBasis.subset_of_forall_subset PrespectralSpace.isTopologicalBasis
          ht1.isOpen_compl ?_
        · exact fun o ⟨ho1, ho2⟩ hot ↦ this o ⟨ho1, ho2, hot⟩
      exact ht2 <| htu.trans <| Set.union_eq_self_of_subset_right <| Set.compl_subset_compl.mp this
    · by_cases h2 : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ uᶜ) → o ∉ F
      · have : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ uᶜ) → o ⊆ tᶜ := by
          intro o ho
          exact Set.subset_compl_comm.1 <| (htu ▸ Set.subset_union_left).trans <|
            Set.sInter_subset_of_mem ⟨isClosed_compl_iff.mpr ho.1,
              (or_iff_not_imp_left.1 <| mem_or_compl_mem F o) (h2 o ho)⟩
        have : uᶜ ⊆ tᶜ := by
          refine IsTopologicalBasis.subset_of_forall_subset PrespectralSpace.isTopologicalBasis
            hu1.isOpen_compl ?_
          · exact fun o ⟨ho1, ho2⟩ hou ↦ this o ⟨ho1, ho2, hou⟩
        exact hu2 <| htu.trans <| Set.union_eq_self_of_subset_left <| Set.compl_subset_compl.mp this
      · simp only [and_imp, not_forall, not_not] at h1 h2
        obtain ⟨o, ho1, ho2, hot, hoF⟩ := h1
        obtain ⟨p, hp1, hp2, hpu, hpF⟩ := h2
        have : o ∩ p ∩ ⋂₀ {s | IsClosed s ∧ s ∈ F} = ∅ := by
          have : p ∩ ⋂₀ {s | IsClosed s ∧ s ∈ F} ⊆ t := by
            intro x ⟨hxp, hx⟩
            apply or_iff_not_imp_right.1 <| htu ▸ hx
            exact hpu hxp
          exact Set.subset_eq_empty
            (Set.inter_assoc _ _ _ ▸ (Set.inter_subset_inter Set.Subset.rfl this)) <|
              Disjoint.inter_eq <| Set.subset_compl_iff_disjoint_right.1 hot
        exact Set.Nonempty.ne_empty
          (Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem
            (QuasiSeparatedSpace.inter_isCompact o p ho1 ho2 hp1 hp2)
              (Filter.inter_mem hoF hpF)) this

lemma singleton_closure_inter_open_nonempty_iff
    {X : Type*} [TopologicalSpace X] (x : X) {o : Set X} (ho : IsOpen o) :
    (closure {x} ∩ o).Nonempty ↔ x ∈ o :=
  (closure_inter_open_nonempty_iff ho).trans Set.singleton_inter_nonempty

namespace ConstructibleTop

instance (X : Type*) [TopologicalSpace X] [T0Space X] [CompactSpace X]
    [QuasiSeparatedSpace X] [PrespectralSpace X] : T2Space (ConstructibleTop X) := by
  simp only [t2Space_iff, exists_and_left,
    instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image]
  intro x y hxy
  obtain ⟨s, hs1, hs2⟩ := not_inseparable_iff_exists_open.1 <| (Decidable.not_imp_not.2 <|
    (t0Space_iff_inseparable X).1 inferInstance x y) hxy
  refine Or.elim hs2 (fun ⟨hxs, hys⟩ ↦ ?_) ?_
  · obtain ⟨t, ht1, ht2, ht3⟩ := (IsTopologicalBasis.mem_nhds_iff <|
      (prespectralSpace_iff X).1 inferInstance).1 <| IsOpen.mem_nhds hs1 hxs
    refine ⟨t, isOpen_generateFrom_of_mem <| Set.mem_union_left _ ht1, ⟨tᶜ, ?_, ?_⟩⟩
    · exact isOpen_generateFrom_of_mem <| Set.mem_union_right _ ⟨t, ht1, rfl⟩
    · exact ⟨ht2, fun h => hys (ht3 h), Set.disjoint_compl_right_iff_subset.mpr fun _ h => h⟩
  · intro ⟨hys, hxs⟩
    obtain ⟨t, ⟨ht1, ht2⟩, ht3, ht4⟩ := (IsTopologicalBasis.mem_nhds_iff <|
      (prespectralSpace_iff X).1 inferInstance).1 <| IsOpen.mem_nhds hs1 hys
    refine ⟨tᶜ, isOpen_generateFrom_of_mem <| Set.mem_union_right _ ⟨t, ⟨ht1, ht2⟩, rfl⟩, ⟨t, ?_, ?_⟩⟩
    · exact isOpen_generateFrom_of_mem <| Set.mem_union_left _ ⟨ht1, ht2⟩
    · exact ⟨fun h => hxs (ht4 h), ht3, Set.disjoint_compl_left_iff_subset.mpr fun _ h => h⟩

instance (X : Type*) [TopologicalSpace X] [CompactSpace X] [QuasiSober X] [QuasiSeparatedSpace X]
    [PrespectralSpace X] : CompactSpace (ConstructibleTop X) := by
  rw [instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image,
    ← @isCompact_univ_iff, @isCompact_iff_ultrafilter_le_nhds']
  intro F _
  by_contra h
  have h1 : ∀ x : X, ∃ t, x ∈ t ∧ t ∈ { s : Set X | IsOpen s ∧ IsCompact s } ∪
      compl '' { s : Set X | IsOpen s ∧ IsCompact s } ∧ t ∉ F := by
    simpa [nhds_generateFrom] using h
  obtain ⟨x, hx⟩ := @QuasiSober.sober X _ _ _
    (@Ultrafilter.sInter_isIrreducible_of_isClosed_mem X _ _ _ _ F)
    (isClosed_sInter fun _ h => h.1)
  have h2 : ∀ t ∈ { s | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s },
      x ∈ t → t ∈ F := by
    intro t ht hxt
    by_contra htF
    refine Or.elim ht (fun ⟨ht1, ht2⟩ ↦ ?_) (fun ⟨o, ⟨ho1, ho2⟩, hot⟩ ↦ ?_)
    · exact ((Set.sInter_subset_of_mem (Set.mem_sep (isClosed_compl_iff.mpr ht1)
        (Ultrafilter.compl_mem_iff_notMem.mpr htF))) (IsGenericPoint.mem hx)) hxt
    · exact (hot ▸ hxt) ((singleton_closure_inter_open_nonempty_iff x ho1).1
        (Set.inter_comm _ _ ▸ hx ▸ Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem ho2
          (Ultrafilter.compl_notMem_iff.mp (hot ▸ htF))))
  obtain ⟨t, hxt, ht, htF⟩ := h1 x
  exact htF (h2 t ht hxt)

end ConstructibleTop

end Theorem1

section CommentsBetweenThm1AndCorollaries

lemma exists_of_isOpen_isCompact_isEmbedding
    {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [PrespectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) {s : Set X} (hs1 : IsOpen s) (hs2 : IsCompact s) :
    ∃ o : Set Y, IsOpen o ∧ IsCompact o ∧ s = f ⁻¹' o := by
  obtain ⟨S, hS⟩ := eq_sUnion_finset_of_isTopologicalBasis_of_isCompact_open _ (hf.eq_induced ▸
    IsTopologicalBasis.induced f (PrespectralSpace.isTopologicalBasis (X := Y))) s hs2 hs1
  have : ∀ s ∈ S, ∃ o : Set Y, IsOpen o ∧ IsCompact o ∧ s = f ⁻¹' o :=
    fun ⟨s, o, ⟨ho1, ho2⟩, hfos⟩ hsS => ⟨o, ho1, ho2, hfos.symm⟩
  choose! U hU1 hU2 hU3 using this
  refine ⟨⋃ s ∈ S, U s, isOpen_biUnion hU1, Finset.isCompact_biUnion S hU2, ?_⟩
  · exact (Set.sUnion_image _ _ ▸ hS) ▸ Set.biUnion_eq_iUnion _ _ ▸ Set.biUnion_eq_iUnion _ _ ▸
      Set.preimage_iUnion.symm ▸ Set.iUnion_congr fun ⟨t, ht⟩ => hU3 t ht

lemma ConstructibleTop.instTopologicalSpace_eq_induced_of_isEmbedding_isSpectralMap {X Y : Type*}
    [TopologicalSpace X] [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X]
    [TopologicalSpace Y] [CompactSpace Y] [QuasiSeparatedSpace Y] [PrespectralSpace Y]
    {f : X → Y} (hf1 : IsEmbedding f) (hf2 : IsSpectralMap f) :
    instTopologicalSpace X = induced f (instTopologicalSpace Y) := by
  rw [instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image X,
    instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image Y,
    induced_generateFrom_eq]
  refine eq_of_le_of_le (le_generateFrom fun s ⟨t, ht, hts⟩ => ?_) (le_generateFrom fun s hs => ?_)
  · refine Or.elim ht (fun ⟨ht1, ht2⟩ => ?_) (fun ⟨u, ⟨hu1, hu2⟩, hut⟩ => ?_)
    · exact hts ▸ generateFrom_isConstructible_eq_generateFrom_union_compl_image X ▸
        (TopologicalSpace.le_def.1 <| instTopologicalSpace_le X) _
          (IsOpen.preimage hf1.continuous ht1)
    · exact hts ▸ hut ▸ (isOpen_generateFrom_of_mem <|
        Or.intro_right _ ⟨f ⁻¹' u, ⟨IsOpen.preimage hf1.continuous hu1,
          hf2.isCompact_preimage_of_isOpen hu1 hu2⟩, rfl⟩)
  · refine isOpen_generateFrom_of_mem <| Or.elim hs ?_ ?_
    · intro ⟨hs1, hs2⟩
      obtain ⟨o, ho1, ho2, hsfo⟩ := exists_of_isOpen_isCompact_isEmbedding hf1 hs1 hs2
      exact ⟨o, Or.intro_left _ ⟨ho1, ho2⟩, hsfo.symm⟩
    · intro ⟨o, ⟨ho1, ho2⟩, hos⟩
      obtain ⟨t, ht1, ht2, hoft⟩ := exists_of_isOpen_isCompact_isEmbedding hf1 ho1 ho2
      exact ⟨tᶜ, Or.intro_right _ ⟨t, ⟨ht1, ht2⟩, rfl⟩, Set.preimage_compl.symm ▸ hoft ▸ hos⟩

lemma IsSpectralMap.continuous_constructibleTop {X Y : Type*} [TopologicalSpace X] [CompactSpace X]
    [QuasiSeparatedSpace X] [TopologicalSpace Y] [CompactSpace Y] [QuasiSeparatedSpace Y]
    {f : X → Y} (hf : IsSpectralMap f) :
    Continuous (X := ConstructibleTop X) (Y := ConstructibleTop Y) f := by
  rw [instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image X,
    instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image Y]
  refine continuous_generateFrom_iff.2 ?_
  · intro s hs
    refine Or.elim hs ?_ ?_
    · intro ⟨hs1, hs2⟩
      exact isOpen_generateFrom_of_mem <| Or.intro_left _ ⟨hf.1.isOpen_preimage s hs1, hf.2 hs1 hs2⟩
    · intro ⟨o, ⟨ho1, ho2⟩, hos⟩
      exact isOpen_generateFrom_of_mem <| Or.intro_right _ <| hos ▸
        ⟨f ⁻¹' o, ⟨hf.1.isOpen_preimage o ho1, hf.2 ho1 ho2⟩, rfl⟩

lemma IsClosed.of_le_of_isClosed {X : Type*} [S : TopologicalSpace X] [T : TopologicalSpace X]
    (hST : S ≤ T) {s : Set X} (hs : @IsClosed _ T s) : @IsClosed _ S s :=
  (@isOpen_compl_iff _ _ S).1 (hST sᶜ hs.isOpen_compl)

lemma IsCompact.of_le_of_isCompact {X : Type*} [S : TopologicalSpace X] [T : TopologicalSpace X]
    (hST : S ≤ T) {s : Set X} (hs : @IsCompact _ S s) : @IsCompact _ T s := by
  refine isCompact_iff_finite_subcover.2 ?_
  intro ι U hιU hsU
  exact (@isCompact_iff_finite_subcover X S s).1 hs U (fun i => hST (U i) (hιU i)) hsU

lemma IsSpectralMap.of_continuous_of_continuous_constructibleTop {X Y : Type*}
    [TopologicalSpace X] [CompactSpace X] [QuasiSober X] [QuasiSeparatedSpace X]
    [PrespectralSpace X] [TopologicalSpace Y] [CompactSpace Y] [QuasiSeparatedSpace Y]
    {f : X → Y} (hf1 : Continuous f)
    (hf2 : Continuous (X := ConstructibleTop X) (Y := ConstructibleTop Y) f) :
    IsSpectralMap f := by
  refine ⟨hf1, ?_⟩
  · intro s hs1 hs2
    have : IsCompact (X := ConstructibleTop X) (f ⁻¹' s) := by
      refine IsClosed.isCompact <| IsClosed.preimage (X := ConstructibleTop X)
        (Y := ConstructibleTop Y) hf2 ?_
      · rw [instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image]
        exact (@isOpen_compl_iff _ _ (generateFrom _)).1 <| isOpen_generateFrom_of_mem <|
          Or.intro_right _ ⟨s, ⟨hs1, hs2⟩, rfl⟩
    exact IsCompact.of_le_of_isCompact (S := instTopologicalSpace X)
      (T := (inferInstance : TopologicalSpace X)) (instTopologicalSpace_le X) this

lemma isSpectralMap_iff_continuous_and_continuous_constructibleTop
    {X Y : Type*} [TopologicalSpace X] [CompactSpace X] [QuasiSober X] [QuasiSeparatedSpace X]
    [PrespectralSpace X] [TopologicalSpace Y] [CompactSpace Y] [QuasiSeparatedSpace Y] (f : X → Y) :
    IsSpectralMap f ↔
    Continuous f ∧ Continuous (X := ConstructibleTop X) (Y := ConstructibleTop Y) f :=
  ⟨fun hf => ⟨hf.toContinuous, hf.continuous_constructibleTop⟩,
    fun ⟨hf1, hf2⟩ => IsSpectralMap.of_continuous_of_continuous_constructibleTop hf1 hf2⟩

lemma IsSpectralMap.isClosed_range {X Y : Type*} [TopologicalSpace X] [CompactSpace X]
    [QuasiSober X] [QuasiSeparatedSpace X] [PrespectralSpace X] [TopologicalSpace Y]
    [T0Space Y] [CompactSpace Y] [QuasiSeparatedSpace Y] [PrespectralSpace Y]
    {f : X → Y} (hf : IsSpectralMap f) :
    IsClosed (X := ConstructibleTop Y) (Set.range f) :=
  IsCompact.isClosed <| isCompact_range (X := ConstructibleTop X) (Y := ConstructibleTop Y) <|
    IsSpectralMap.continuous_constructibleTop hf

lemma compactSpace_of_isEmbedding_of_isClosed_constructibleTop_range {X Y : Type*}
    [TopologicalSpace X] [T : TopologicalSpace Y] [CompactSpace Y] [QuasiSober Y]
    [QuasiSeparatedSpace Y] [PrespectralSpace Y] {f : X → Y} (hf : IsEmbedding f)
    (hfX : IsClosed (X := ConstructibleTop Y) (Set.range f)) :
    CompactSpace X :=
  ⟨(IsEmbedding.isCompact_iff hf).2
    (Set.image_univ ▸ IsCompact.of_le_of_isCompact (S := instTopologicalSpace Y) (T := T)
      (instTopologicalSpace_le Y) (IsClosed.isCompact hfX))⟩

lemma quasiSober_of_isEmbedding_of_isClosed_constructibleTop_range
    {X Y : Type*} [TopologicalSpace X] [T : TopologicalSpace Y]
    [CompactSpace Y] [QuasiSober Y] [QuasiSeparatedSpace Y] [PrespectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) (hfX : IsClosed (X := ConstructibleTop Y) (Set.range f)) :
    QuasiSober X := by
  refine ⟨fun {s} hs1 hs2 => ?_⟩
  · have h1 : IsCompact (X := ConstructibleTop Y) (s.image f) := by
      obtain ⟨t, ht, hfts⟩ := isClosed_induced_iff.1 (hf.eq_induced ▸ hs2)
      refine hfts ▸ Set.image_preimage_eq_inter_range ▸
        (IsClosed.isCompact <| IsClosed.inter ?_ hfX)
      · exact IsClosed.of_le_of_isClosed (S := instTopologicalSpace Y) (T := T)
          (instTopologicalSpace_le Y) ht
    let ι := { t : Set Y | IsOpen t ∧ IsCompact t ∧ t ∩ f '' s ≠ ∅ }
    let t : ι → Set Y := fun i => i.1
    have h2 : ∀ u : Finset ι, f '' s ∩ ⋂ i ∈ u, t i ≠ ∅ := by
      intro u
      let U := u.image (fun i : ι => f ⁻¹' i)
      have hsU : (s ∩ ⋂₀ U).Nonempty :=
        isIrreducible_iff_sInter.1 hs1 U (fun t htU => (Finset.mem_image.1 htU).choose_spec.2 ▸
          IsOpen.preimage hf.continuous (Finset.mem_image.1 htU).choose.2.1)
          (fun t htU => (Finset.mem_image.1 htU).choose_spec.2 ▸ Set.image_nonempty.mp
            (Set.nonempty_iff_ne_empty.2 (Set.image_inter_preimage _ _ _ ▸
              Set.inter_comm _ _ ▸ (Finset.mem_image.1 htU).choose.2.2.2)))
      have hfsU : (f '' s ∩ ⋂ s ∈ U, f '' s).Nonempty :=
        Set.Nonempty.mono (Set.inter_subset_inter_right (f '' s) (U.toSet.image_sInter_subset f))
        (Set.image_inter hf.injective ▸ Set.Nonempty.image f hsU)
      have hfstU : ⋂ s ∈ U, f '' s ⊆ ⋂ i ∈ u, t i := by
        simp only [Set.iInter_coe_set, Set.subset_iInter_iff]
        intro r ⟨hr1, hr2, hrfs⟩ hru
        refine Set.iInter_subset_of_subset (f ⁻¹' r) ?_
        · intro y hy
          simp only [Set.mem_iInter] at hy
          obtain ⟨x, hfxr, hfxy⟩ := hy <| Finset.mem_image.mpr (by use ⟨r, hr1, hr2, hrfs⟩)
          exact hfxy ▸ hfxr
      exact Set.nonempty_iff_ne_empty.mp <| Set.Nonempty.mono
        (Set.inter_subset_inter_right (f '' s) hfstU) hfsU
    have h3 : (f '' s ∩ ⋂ i, t i).Nonempty := Set.nonempty_iff_ne_empty.mpr <|
      (not_imp_not.2 <| isCompact_iff_finite_subfamily_closed.1 h1 t
        (fun i => isOpen_compl_iff.1 <|
          instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image Y ▸
            isOpen_generateFrom_of_mem <| Or.intro_right _ ⟨i, ⟨i.2.1, i.2.2.1⟩, rfl⟩))
      (not_exists.2 h2)
    obtain ⟨x, hx⟩ := Set.preimage_iInter ▸ Set.preimage_image_eq s hf.injective ▸
      Set.preimage_inter ▸ Set.Nonempty.preimage' h3 (Set.inter_subset_left.trans
        (Set.image_subset_range f s))
    use x
    refine eq_of_le_of_le ((IsClosed.closure_subset_iff hs2).2
      (Set.singleton_subset_iff.mpr hx.1)) fun y hys => (IsTopologicalBasis.mem_closure_iff
        (hf.eq_induced ▸ IsTopologicalBasis.induced f (PrespectralSpace.isTopologicalBasis))).2 ?_
    · intro o ⟨r, ⟨hr1, hr2⟩, hfro⟩ hyo
      exact hfro ▸ Set.inter_singleton_nonempty.mpr (Set.mem_iInter.1 hx.2
        ⟨r, hr1, hr2, Set.nonempty_iff_ne_empty.mp
          ⟨f y, Set.mem_preimage.1 (hfro ▸ hyo), Set.mem_image_of_mem f hys⟩⟩)

lemma isOpen_and_isCompact_iff_exists_of_isEmbedding_of_isClosed_constructibleTop_range
    {X Y : Type*} [TopologicalSpace X] [T : TopologicalSpace Y] [CompactSpace Y] [QuasiSober Y]
    [QuasiSeparatedSpace Y] [PrespectralSpace Y] {f : X → Y} (hf : IsEmbedding f)
    (hfX : IsClosed (X := ConstructibleTop Y) (Set.range f)) (s : Set X) :
    (IsOpen s ∧ IsCompact s) ↔ ∃ o : Set Y, IsOpen o ∧ IsCompact o ∧ s = f ⁻¹' o := by
  refine ⟨fun ⟨hs1, hs2⟩ => exists_of_isOpen_isCompact_isEmbedding hf hs1 hs2, ?_⟩
  · intro ⟨o, ho1, ho2, hsfo⟩
    refine ⟨hsfo ▸ IsOpen.preimage hf.continuous ho1, ?_⟩
    · have h1 : IsClosed (X := ConstructibleTop Y) o := isOpen_compl_iff.1 <|
          instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image Y ▸
            isOpen_generateFrom_of_mem <| Or.intro_right _ ⟨o, ⟨ho1, ho2⟩, rfl⟩
      have h2 : IsCompact (f '' s) := (hsfo ▸ Set.image_preimage_eq_range_inter.symm) ▸
        (IsCompact.of_le_of_isCompact (S := instTopologicalSpace Y) (T := T)
          (instTopologicalSpace_le Y) <| IsClosed.isCompact (IsClosed.inter hfX h1))
      exact (IsEmbedding.isCompact_iff hf).2 h2

lemma quasiSeparatedSpace_of_isEmbedding_of_isClosed_constructibleTop_range
    {X Y : Type*} [TopologicalSpace X] [T : TopologicalSpace Y]
    [CompactSpace Y] [QuasiSober Y] [QuasiSeparatedSpace Y] [PrespectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) (hfX : IsClosed (X := ConstructibleTop Y) (Set.range f)) :
    QuasiSeparatedSpace X := by
  refine ⟨fun s t hs1 hs2 ht1 ht2 => ?_⟩
  · obtain ⟨u, hu1, hu2, hsfu⟩ :=
      (isOpen_and_isCompact_iff_exists_of_isEmbedding_of_isClosed_constructibleTop_range hf hfX s).1
        ⟨hs1, hs2⟩
    obtain ⟨v, hv1, hv2, htfv⟩ :=
      (isOpen_and_isCompact_iff_exists_of_isEmbedding_of_isClosed_constructibleTop_range hf hfX t).1
        ⟨ht1, ht2⟩
    exact hsfu ▸ htfv ▸ Set.preimage_inter ▸
      ((isOpen_and_isCompact_iff_exists_of_isEmbedding_of_isClosed_constructibleTop_range
        hf hfX (f ⁻¹' (u ∩ v))).2 ⟨u ∩ v, IsOpen.inter hu1 hv1,
          QuasiSeparatedSpace.inter_isCompact u v hu1 hu2 hv1 hv2, rfl⟩).2

lemma prespectralSpace_of_isEmbedding_of_isClosed_constructibleTop_range
    {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [CompactSpace Y] [QuasiSober Y]
    [QuasiSeparatedSpace Y] [PrespectralSpace Y] {f : X → Y} (hf : IsEmbedding f)
    (hfX : IsClosed (X := ConstructibleTop Y) (Set.range f)) :
    PrespectralSpace X := by
  constructor
  · have : Set.preimage f '' { s | IsOpen s ∧ IsCompact s } = { s | IsOpen s ∧ IsCompact s } := by
      ext s; constructor
      · intro ⟨o, ⟨ho1, ho2⟩, hfos⟩
        exact hfos ▸ ⟨IsOpen.preimage hf.continuous ho1,
          ((isOpen_and_isCompact_iff_exists_of_isEmbedding_of_isClosed_constructibleTop_range
            hf hfX (f ⁻¹' o)).2 ⟨o, ho1, ho2, rfl⟩).2⟩
      · intro hs
        obtain ⟨u, hu1, hu2, hsfu⟩ :=
          (isOpen_and_isCompact_iff_exists_of_isEmbedding_of_isClosed_constructibleTop_range
            hf hfX s).1 hs
        exact hsfu ▸ ⟨u, ⟨hu1, hu2⟩, rfl⟩
    exact this ▸ hf.eq_induced ▸ IsTopologicalBasis.induced f PrespectralSpace.isTopologicalBasis

lemma spectralSpace_of_isEmbedding_of_isClosed_constructibleTop_range
    {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) (hfX : IsClosed (X := ConstructibleTop Y) (Set.range f)) :
    SpectralSpace X where
  t0 := (IsEmbedding.t0Space hf).1
  isCompact_univ := (compactSpace_of_isEmbedding_of_isClosed_constructibleTop_range hf hfX).1
  sober := (quasiSober_of_isEmbedding_of_isClosed_constructibleTop_range hf hfX).1
  inter_isCompact :=
    (quasiSeparatedSpace_of_isEmbedding_of_isClosed_constructibleTop_range hf hfX).1
  isTopologicalBasis :=
    (prespectralSpace_of_isEmbedding_of_isClosed_constructibleTop_range hf hfX).1

lemma spectralSpace_and_isSpectralMap_iff_isClosed_constructibleTop_range
    {X Y : Type*} [TopologicalSpace X] [T : TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) :
    (SpectralSpace X ∧ IsSpectralMap f) ↔ IsClosed (X := ConstructibleTop Y) (Set.range f) := by
  refine ⟨fun h => haveI := h.1; h.2.isClosed_range,
    fun h => ⟨spectralSpace_of_isEmbedding_of_isClosed_constructibleTop_range hf h, hf.continuous,
      fun s hs1 hs2 => ?_⟩⟩
  · have h1 : IsClosed (X := ConstructibleTop Y) s :=
      ⟨instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image Y ▸
        isOpen_generateFrom_of_mem <| Or.intro_right _ ⟨s, ⟨hs1, hs2⟩, rfl⟩⟩
    have h2 : IsCompact (s ∩ Set.range f) :=
      ((IsClosed.isCompact h).inter_left h1).of_le_of_isCompact (S := instTopologicalSpace Y)
        (T := T) (instTopologicalSpace_le Y)
    exact Set.preimage_inter_range.symm ▸ hf.isCompact_iff.2
      ((Set.image_preimage_eq_of_subset Set.inter_subset_right).symm ▸ h2)

end CommentsBetweenThm1AndCorollaries

section Corollaries

lemma Set.Finite.sInter_mem_of_finiteInter {α : Type*} {S : Set (Set α)}
    (hS : FiniteInter S) {F : Set (Set α)} (hF : F.Finite) :
    F ⊆ S → ⋂₀ F ∈ S := fun hFS => by
  simpa only [Set.Finite.coe_toFinset] using FiniteInter.finiteInter_mem hS hF.toFinset
    (fun f hfF => hFS ((Set.Finite.mem_toFinset hF).1 hfF))

lemma Set.Finite.sInter_ne_empty_of_finiteInter_finiteInter_of_subset_union
    {α : Type*} {S T U : Set (Set α)} (hS : FiniteInter S) (hT : FiniteInter T)
    (hST : ∀ s ∈ S, ∀ t ∈ T, s ∩ t ≠ ∅) (hU : U.Finite) (hUST : U ⊆ S ∪ T) :
    ⋂₀ U ≠ ∅ :=
  (Set.inter_union_distrib_left U S T ▸ Set.left_eq_inter.2 hUST) ▸
    Set.sInter_union _ _ ▸ hST _
      (Set.Finite.sInter_mem_of_finiteInter hS (Set.Finite.inter_of_left hU S)
        Set.inter_subset_right) _
      (Set.Finite.sInter_mem_of_finiteInter hT (Set.Finite.inter_of_left hU T)
        Set.inter_subset_right)

lemma mem_patch_closure_iff_mem_pt_closure {X : Type*} [TopologicalSpace X]
    [CompactSpace X] [QuasiSober X] [QuasiSeparatedSpace X] [PrespectralSpace X]
    {Y : Set X} (hY : IsClosed (X := ConstructibleTop X) Y) (x : X) :
    x ∈ closure Y ↔ ∃ y ∈ Y, x ∈ closure {y} := by
  refine ⟨fun hxY => ?_, fun ⟨y, hyY, hxy⟩ => closure_mono (Set.singleton_subset_iff.2 hyY) hxy⟩
  · have : (Y ∩ ⋂₀ { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s }).Nonempty := by
      by_contra h
      let ι := { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s }
      let t : ι → Set X := fun i => i.1
      have hιt : ∀ i : ι, IsClosed (X := ConstructibleTop X) (t i) := fun ⟨i, hiι⟩ =>
        ⟨instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image X ▸
          isOpen_generateFrom_of_mem <| Or.intro_right _ ⟨i, ⟨hiι.1, hiι.2.1⟩, rfl⟩⟩
      have := (isCompact_iff_finite_subfamily_closed (X := ConstructibleTop X)).1
        (IsClosed.isCompact hY) t hιt
      simp only [t, ← Set.sInter_eq_iInter] at this
      obtain ⟨U', hYU'⟩ := this (Set.not_nonempty_iff_eq_empty.1 h)
      let U : Set (Set X) := Subtype.val '' U'.toSet
      have hU1 : U.Finite := U.toFinite
      have hU2 : U ⊆ { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } :=
        Subtype.coe_image_subset { s | IsOpen s ∧ IsCompact s ∧ x ∈ s } U'
      have hx : FiniteInter { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } :=
        ⟨⟨isOpen_univ, CompactSpace.isCompact_univ, trivial⟩,
          fun s ⟨hs1, hs2, hxs⟩ t ⟨ht1, ht2, hxt⟩ =>
          ⟨IsOpen.inter hs1 ht1, IsCompact.inter_of_isOpen hs2 ht2 hs1 ht1, Set.mem_inter hxs hxt⟩⟩
      obtain ⟨hU3, hU4, hxU⟩ := Set.Finite.sInter_mem_of_finiteInter hx hU1 hU2
      exact Set.nonempty_iff_ne_empty.1 (Set.inter_comm _ _ ▸
        ((mem_closure_iff PrespectralSpace.isTopologicalBasis).1 hxY) (⋂₀ U) ⟨hU3, hU4⟩ hxU)
        ((Set.sInter_eq_biInter ▸ Eq.symm Set.biInter_image) ▸ hYU')
    obtain ⟨y, hyY, hyx⟩ := this
    exact ⟨y, hyY, (mem_closure_iff PrespectralSpace.isTopologicalBasis).2
      fun s ⟨hs1, hs2⟩ hxs => Set.inter_singleton_nonempty.2 (hyx s ⟨hs1, hs2, hxs⟩)⟩

lemma exist_open_disjoint_or_mem_pt_closure {X : Type*} [TopologicalSpace X]
    [CompactSpace X] [QuasiSober X] [QuasiSeparatedSpace X] [PrespectralSpace X] (x y : X) :
    (∃ O1 O2, IsOpen O1 ∧ IsOpen O2 ∧ x ∈ O1 ∧ y ∈ O2 ∧ Disjoint O1 O2) ∨
    (∃ z, x ∈ closure {z} ∧ y ∈ closure {z}) := by
  refine Decidable.or_iff_not_imp_left.2 ?_
  · simp only [exists_and_left, not_exists, not_and]
    intro h
    have : (⋂₀ ({ s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } ∪
        { s | IsOpen s ∧ IsCompact s ∧ y ∈ s })).Nonempty := by
      by_contra h'
      let ι := { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } ∪
        { s : Set X | IsOpen s ∧ IsCompact s ∧ y ∈ s }
      let t : ι → Set X := fun i => i.1
      have hιt : ∀ i : ι, IsClosed (X := ConstructibleTop X) (t i) := fun ⟨i, hiι⟩ =>
        ⟨instTopologicalSpace_eq_generateFrom_isOpen_isCompact_union_compl_image X ▸
          isOpen_generateFrom_of_mem <| Or.elim hiι
            (fun ⟨hi1, hi2, _⟩ => Or.intro_right _ ⟨i, ⟨hi1, hi2⟩, rfl⟩)
            (fun ⟨hi1, hi2, _⟩ => Or.intro_right _ ⟨i, ⟨hi1, hi2⟩, rfl⟩)⟩
      have := (isCompact_iff_finite_subfamily_closed (X := ConstructibleTop X)).1
        CompactSpace.isCompact_univ t hιt
      simp only [Set.univ_inter, t, ← Set.sInter_eq_iInter] at this
      obtain ⟨U', hU'⟩ := this (Set.not_nonempty_iff_eq_empty.1 h')
      let U : Set (Set X) := Subtype.val '' U'.toSet
      have hU1 : U.Finite := U.toFinite
      have hU2 : U ⊆ { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } ∪
          { s | IsOpen s ∧ IsCompact s ∧ y ∈ s } :=
        Subtype.coe_image_subset ({ s | IsOpen s ∧ IsCompact s ∧ x ∈ s } ∪
          { s | IsOpen s ∧ IsCompact s ∧ y ∈ s }) U'
      have hx : FiniteInter { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } :=
        ⟨⟨isOpen_univ, CompactSpace.isCompact_univ, trivial⟩,
          fun s ⟨hs1, hs2, hxs⟩ t ⟨ht1, ht2, hxt⟩ =>
          ⟨IsOpen.inter hs1 ht1, IsCompact.inter_of_isOpen hs2 ht2 hs1 ht1, Set.mem_inter hxs hxt⟩⟩
      have hy : FiniteInter { s : Set X | IsOpen s ∧ IsCompact s ∧ y ∈ s } :=
        ⟨⟨isOpen_univ, CompactSpace.isCompact_univ, trivial⟩,
          fun s ⟨hs1, hs2, hys⟩ t ⟨ht1, ht2, hyt⟩ =>
          ⟨IsOpen.inter hs1 ht1, IsCompact.inter_of_isOpen hs2 ht2 hs1 ht1, Set.mem_inter hys hyt⟩⟩
      exact Set.Finite.sInter_ne_empty_of_finiteInter_finiteInter_of_subset_union hx hy
        (fun s ⟨hs1, hs2, hxs⟩ t ⟨ht1, ht2, hyt⟩ => Set.nonempty_iff_ne_empty.1
          (Set.not_disjoint_iff_nonempty_inter.1 (h s hs1 t ht1 hxs hyt)))
        hU1 hU2 ((Set.sInter_eq_biInter ▸ Eq.symm Set.biInter_image) ▸ hU')
    obtain ⟨z, hzx, hzy⟩ := Set.sInter_union _ _ ▸ this
    refine ⟨z, ?_, ?_⟩
    · exact (mem_closure_iff PrespectralSpace.isTopologicalBasis).2
        fun s ⟨hs1, hs2⟩ hxs => Set.inter_singleton_nonempty.2 (hzx s ⟨hs1, hs2, hxs⟩)
    · exact (mem_closure_iff PrespectralSpace.isTopologicalBasis).2
        fun s ⟨hs1, hs2⟩ hys => Set.inter_singleton_nonempty.2 (hzy s ⟨hs1, hs2, hys⟩)

end Corollaries
