import Mathlib.Topology.Constructible
import Mathlib.Topology.Spectral.Basic

open Classical TopologicalSpace.IsTopologicalBasis TopologicalSpace Topology

section BasicsOfConstructibleTop

/--
The constructible topology on a topological space `X` is generated by the constructible subsets of
`X`.
-/
def ConstructibleTop (X : Type*) [TopologicalSpace X] := X

namespace ConstructibleTop

def toConstructibleTop (X : Type*) [TopologicalSpace X] :
    X ≃ ConstructibleTop X where
  toFun := id
  invFun := id
  left_inv _ := rfl
  right_inv _ := rfl

def ofConstructibleTop (X : Type*) [TopologicalSpace X] :
    ConstructibleTop X ≃ X where
  toFun := id
  invFun := id
  left_inv _ := rfl
  right_inv _ := rfl

instance (X : Type*) [TopologicalSpace X] :
    TopologicalSpace (ConstructibleTop X) :=
  generateFrom { s : Set X | IsConstructible s }

end ConstructibleTop

theorem latticeClosure.sup_inf_induction {α : Type*} [Lattice α]
    {s : Set α} (p : (a : α) → a ∈ latticeClosure s → Prop)
    (mem : ∀ (a : α) (has : a ∈ s), p a (subset_latticeClosure has))
    (sup : ∀ (a : α) (has : a ∈ latticeClosure s) (b : α) (hbs : b ∈ latticeClosure s),
      p a has → p b hbs → p (a ⊔ b) (IsSublattice.supClosed isSublattice_latticeClosure has hbs))
    (inf : ∀ (a : α) (has : a ∈ latticeClosure s) (b : α) (hbs : b ∈ latticeClosure s),
      p a has → p b hbs → p (a ⊓ b) (IsSublattice.infClosed isSublattice_latticeClosure has hbs))
    {a : α} (has : a ∈ latticeClosure s) :
    p a has := by
  have h1 : s ⊆ { a : α | ∃ has : a ∈ latticeClosure s, p a has } := by
    intro a ha
    exact ⟨subset_latticeClosure ha, mem a ha⟩
  have h2 : IsSublattice { a : α | ∃ has : a ∈ latticeClosure s, p a has } := {
    supClosed := fun a ⟨has, hpa⟩ b ⟨hbs, hpb⟩ =>
      ⟨IsSublattice.supClosed isSublattice_latticeClosure has hbs, sup a has b hbs hpa hpb⟩
    infClosed := fun a ⟨has, hpa⟩ b ⟨hbs, hpb⟩ =>
      ⟨IsSublattice.infClosed isSublattice_latticeClosure has hbs, inf a has b hbs hpa hpb⟩ }
  exact (latticeClosure_min h1 h2 has).choose_spec

lemma Set.compl_image_latticeClosure {X : Type*} (S : Set (Set X)) :
    compl '' (latticeClosure S) = latticeClosure (compl '' S) := by
  refine Set.eq_of_subset_of_subset ?_ ?_
  · intro s ⟨c, hcS, hcs⟩
    refine hcs ▸ latticeClosure.sup_inf_induction (fun c hcS => cᶜ ∈ latticeClosure (compl '' S))
      ?_ ?_ ?_ hcS
    · intro c hcS
      exact subset_latticeClosure <| Set.mem_image_of_mem compl hcS
    · intro a _ b _ haS hbS
      exact Set.compl_union _ _ ▸ IsSublattice.infClosed isSublattice_latticeClosure haS hbS
    · intro a _ b _ haS hbS
      exact Set.compl_inter _ _ ▸ IsSublattice.supClosed isSublattice_latticeClosure haS hbS
  · refine latticeClosure_min ?_ ?_
    · intro s ⟨c, hcS, hcs⟩
      exact ⟨c, subset_latticeClosure hcS, hcs⟩
    · exact {
      supClosed := fun a ⟨c, hcS, hca⟩ b ⟨d, hdS, hdb⟩ =>
        ⟨aᶜ ⊓ bᶜ, hca ▸ hdb ▸ IsSublattice.infClosed isSublattice_latticeClosure
          ((compl_compl c).symm ▸ hcS) ((compl_compl d).symm ▸ hdS),
            Set.compl_inter _ _ ▸ (compl_compl a).symm ▸ (compl_compl b).symm ▸ rfl⟩
      infClosed := fun a ⟨c, hcS, hca⟩ b ⟨d, hdS, hdb⟩ =>
        ⟨aᶜ ⊔ bᶜ, hca ▸ hdb ▸ IsSublattice.supClosed isSublattice_latticeClosure
          ((compl_compl c).symm ▸ hcS) ((compl_compl d).symm ▸ hdS),
            Set.compl_union _ _ ▸ (compl_compl a).symm ▸ (compl_compl b).symm ▸ rfl⟩ }

lemma Set.compl_image_latticeClosure_eq_of_compl_image_eq_self
    {X : Type*} {S : Set (Set X)} (hS : compl '' S = S) :
    compl '' (latticeClosure S) = latticeClosure S :=
  Set.compl_image_latticeClosure S ▸ hS.symm ▸ rfl

namespace TopologicalSpace

lemma generateFrom_latticeClosure {X : Type*} (S : Set (Set X)) :
    generateFrom (latticeClosure S) = generateFrom S := by
  refine eq_of_le_of_le ?_ ?_
  · refine le_generateFrom ?_
    · intro o hoS
      exact isOpen_generateFrom_of_mem <| subset_latticeClosure hoS
  · refine le_generateFrom ?_
    · intro o hoS
      refine latticeClosure.sup_inf_induction (fun s _ => IsOpen[generateFrom S] s) ?_ ?_ ?_ hoS
      · intro _ h
        exact isOpen_generateFrom_of_mem h
      · intro _ _ _ _ h1 h2
        exact @IsOpen.union X _ _ (generateFrom S) h1 h2
      · intro _ _ _ _ h1 h2
        exact @IsOpen.inter X (generateFrom S) _ _ h1 h2

lemma generateFrom_booleanSubalgebra_closure_eq_of_isSublattice {X : Type*}
    {S : Set (Set X)} (hS1 : ⊥ ∈ S) (hS2 : compl '' S = S) (hS3 : IsSublattice S) :
    generateFrom (BooleanSubalgebra.closure S) = generateFrom S := by
  refine eq_of_le_of_le ?_ ?_
  · refine le_generateFrom ?_
    · intro _ h
      exact isOpen_generateFrom_of_mem <| BooleanSubalgebra.subset_closure h
  · refine le_generateFrom ?_
    · intro s hsS
      refine BooleanSubalgebra.closure_sdiff_sup_induction hS3 hS1 (hS2 ▸ ⟨⊥, hS1, compl_bot⟩)
        ?_ ?_ s hsS
      · intro s hsS t htS
        exact Set.diff_eq_compl_inter ▸
          (isOpen_generateFrom_of_mem <| IsSublattice.infClosed hS3
            (hS2 ▸ Set.mem_image_of_mem compl htS) hsS)
      · intro _ _ _ _ h1 h2
        exact @IsOpen.union _ _ _ (generateFrom S) h1 h2

lemma generateFrom_booleanSubalgebra_closure
    {X : Type*} {S : Set (Set X)} (hS1 : ⊥ ∈ S) (hS2 : compl '' S = S) :
    generateFrom (BooleanSubalgebra.closure S) = generateFrom S :=
  BooleanSubalgebra.closure_latticeClosure S ▸
    generateFrom_booleanSubalgebra_closure_eq_of_isSublattice (subset_latticeClosure hS1)
      (Set.compl_image_latticeClosure_eq_of_compl_image_eq_self hS2) isSublattice_latticeClosure ▸
        generateFrom_latticeClosure S

lemma generateFrom_isConstructible_eq_generateFrom_union_compl_image
    (X : Type*) [TopologicalSpace X] [CompactSpace X] [QuasiSeparatedSpace X] :
    generateFrom { s : Set X | IsConstructible s } =
    generateFrom ({ s | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s }) := by
  have h1 : ⊥ ∈ { s : Set X | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s } :=
    Or.intro_left _ ⟨isOpen_empty, isCompact_empty⟩
  have h2 : compl '' ({ s | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s }) =
      { s : Set X | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s } :=
    (Set.image_union _ _ _).symm ▸
      (Set.compl_compl_image { s : Set X | IsOpen s ∧ IsCompact s }).symm ▸
        Set.union_comm _ _
  refine generateFrom_booleanSubalgebra_closure h1 h2 ▸ ?_
  · congr
    refine Set.eq_of_subset_of_subset ?_ ?_
    · refine BooleanSubalgebra.closure_mono ?_
      · intro s ⟨hs1, hs2⟩
        exact Or.intro_left _ ⟨hs1, (QuasiSeparatedSpace.isRetrocompact_iff_isCompact hs1).1 hs2⟩
    · intro s hs
      simp only [Set.mem_setOf_eq]
      refine BooleanSubalgebra.mem_closure.1 hs ?_
      · intro t ht
        refine Or.elim ht ?_ ?_
        · intro ⟨ht1, ht2⟩
          exact BooleanSubalgebra.subset_closure ⟨ht1,
            (QuasiSeparatedSpace.isRetrocompact_iff_isCompact ht1).2 ht2⟩
        · intro ⟨u, ⟨hu1, hu2⟩, hut⟩
          exact hut ▸ BooleanSubalgebra.compl_mem <| BooleanSubalgebra.subset_closure
            ⟨hu1, (QuasiSeparatedSpace.isRetrocompact_iff_isCompact hu1).2 hu2⟩

end TopologicalSpace

namespace ConstructibleTop

lemma instTopologicalSpace_eq_generateFrom_isOpen_isCompact (X : Type*)
    [TopologicalSpace X] [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] :
    instTopologicalSpace X =
    generateFrom ({ s : Set X | IsOpen s ∧ IsCompact s} ∪
      compl '' { s | IsOpen s ∧ IsCompact s }) := by
  rw [instTopologicalSpace, generateFrom_isConstructible_eq_generateFrom_union_compl_image X]

lemma instTopologicalSpace_le (X : Type*) [T : TopologicalSpace X]
    [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] :
    instTopologicalSpace X ≤ T := by
  rw [instTopologicalSpace, generateFrom_isConstructible_eq_generateFrom_union_compl_image X]
  exact PrespectralSpace.isTopologicalBasis (X := X).eq_generateFrom ▸
    le_generateFrom fun s hs => isOpen_generateFrom_of_mem <|
      PrespectralSpace.isTopologicalBasis (X := X).eq_generateFrom ▸ Or.intro_left _ hs

end ConstructibleTop

end BasicsOfConstructibleTop

section Theorem1

lemma Ultrafilter.sInter_ne_empty_of_isClosed_mem {X : Type*}
    [TopologicalSpace X] [CompactSpace X] (F : Ultrafilter X) :
    ⋂₀ { s : Set X | IsClosed s ∧ s ∈ F } ≠ ∅ := by
  intro h
  let t : { s : Set X | IsClosed s ∧ s ∈ F } → Set X := fun i => i.1
  have := isCompact_iff_finite_subfamily_closed.1 CompactSpace.isCompact_univ t (fun i => i.2.1)
  simp only [Set.univ_inter] at this
  obtain ⟨u, hu⟩ := this (Set.sInter_eq_iInter.symm.trans h)
  exact empty_notMem <| hu ▸ (Filter.biInter_finset_mem u).2 fun i _ => i.2.2

lemma Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem {X : Type*} [TopologicalSpace X]
    {F : Filter X} [F.NeBot] {s : Set X} (hs : IsCompact s) (hsF : s ∈ F) :
    (s ∩ ⋂₀ { s : Set X | IsClosed s ∧ s ∈ F }).Nonempty := by
  refine Set.inter_nonempty.2 ?_
  · obtain ⟨x, hxs, hxF⟩ := IsCompact.exists_clusterPt hs (le_principal_iff.2 hsF)
    use x
    refine ⟨hxs, ?_⟩
    · simp only [Set.mem_sInter, Set.mem_setOf_eq, and_imp]
      intro t ht htF
      exact IsClosed.closure_eq ht ▸ clusterPt_iff_forall_mem_closure.1 hxF t htF

lemma exist_isClosed_union_isClosed_of_isClosed_not_isPreirreducible
    {X : Type*} [TopologicalSpace X] {s : Set X} (hs1 : IsClosed s) (hs2 : ¬IsPreirreducible s) :
    ∃ t u : Set X, IsClosed t ∧ IsClosed u ∧ s = t ∪ u ∧ s ≠ t ∧ s ≠ u := by
  simp [isPreirreducible_iff_isClosed_union_isClosed] at hs2
  obtain ⟨t', ht', u', hu', hstu', hst', hsu'⟩ := hs2
  use t' ∩ s; use u' ∩ s
  exact ⟨IsClosed.inter ht' hs1, IsClosed.inter hu' hs1,
    (Set.inter_eq_self_of_subset_right hstu').symm.trans (Set.union_inter_distrib_right t' u' s),
    fun h => hst' <| Set.right_eq_inter.1 h, fun h => hsu' <| Set.right_eq_inter.1 h⟩

lemma Ultrafilter.sInter_isIrreducible_of_isClosed_mem {X : Type*} [TopologicalSpace X]
    [CompactSpace X] [QuasiSeparatedSpace X] [PrespectralSpace X] (F : Ultrafilter X) :
    IsIrreducible (⋂₀ { s : Set X | IsClosed s ∧ s ∈ F }) := by
  refine ⟨Set.nonempty_iff_ne_empty.2 <| sInter_ne_empty_of_isClosed_mem F, ?_⟩
  · by_contra h
    obtain ⟨t, u, ht1, hu1, htu, ht2, hu2⟩ :=
      exist_isClosed_union_isClosed_of_isClosed_not_isPreirreducible
        (isClosed_sInter fun _ h => h.1) h
    by_cases h1 : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ tᶜ) → o ∉ F
    · have : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ tᶜ) → o ⊆ uᶜ := by
        intro o ho
        exact Set.subset_compl_comm.1 <| (htu ▸ Set.subset_union_right).trans <|
          Set.sInter_subset_of_mem ⟨isClosed_compl_iff.mpr ho.1,
            (or_iff_not_imp_left.1 <| mem_or_compl_mem F o) (h1 o ho)⟩
      have : tᶜ ⊆ uᶜ := by
        refine IsTopologicalBasis.subset_of_forall_subset PrespectralSpace.isTopologicalBasis
          ht1.isOpen_compl ?_
        · intro o ⟨ho1, ho2⟩ hot
          exact this o ⟨ho1, ho2, hot⟩
      exact ht2 <| htu.trans <| Set.union_eq_self_of_subset_right <| Set.compl_subset_compl.mp this
    · by_cases h2 : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ uᶜ) → o ∉ F
      · have : ∀ o : Set X, (IsOpen o ∧ IsCompact o ∧ o ⊆ uᶜ) → o ⊆ tᶜ := by
          intro o ho
          exact Set.subset_compl_comm.1 <| (htu ▸ Set.subset_union_left).trans <|
            Set.sInter_subset_of_mem ⟨isClosed_compl_iff.mpr ho.1,
              (or_iff_not_imp_left.1 <| mem_or_compl_mem F o) (h2 o ho)⟩
        have : uᶜ ⊆ tᶜ := by
          refine IsTopologicalBasis.subset_of_forall_subset PrespectralSpace.isTopologicalBasis
            hu1.isOpen_compl ?_
          · intro o ⟨ho1, ho2⟩ hou
            exact this o ⟨ho1, ho2, hou⟩
        exact hu2 <| htu.trans <| Set.union_eq_self_of_subset_left <| Set.compl_subset_compl.mp this
      · simp only [and_imp, not_forall, not_not] at h1 h2
        obtain ⟨o, ho1, ho2, hot, hoF⟩ := h1
        obtain ⟨p, hp1, hp2, hpu, hpF⟩ := h2
        have : o ∩ p ∩ ⋂₀ {s | IsClosed s ∧ s ∈ F} = ∅ := by
          have : p ∩ ⋂₀ {s | IsClosed s ∧ s ∈ F} ⊆ t := by
            intro x ⟨hxp, hx⟩
            apply or_iff_not_imp_right.1 <| htu ▸ hx
            exact hpu hxp
          exact Set.subset_eq_empty
            (Set.inter_assoc _ _ _ ▸ (Set.inter_subset_inter Set.Subset.rfl this)) <|
              Disjoint.inter_eq <| Set.subset_compl_iff_disjoint_right.1 hot
        exact Set.Nonempty.ne_empty
          (Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem
            (QuasiSeparatedSpace.inter_isCompact o p ho1 ho2 hp1 hp2)
              (Filter.inter_mem hoF hpF)) this

lemma singleton_closure_inter_open_nonempty_iff
    {X : Type*} [TopologicalSpace X] (x : X) {o : Set X} (ho : IsOpen o) :
    (closure {x} ∩ o).Nonempty ↔ x ∈ o :=
  (closure_inter_open_nonempty_iff ho).trans Set.singleton_inter_nonempty

namespace ConstructibleTop

instance t2Space_of_spectralSpace (X : Type*) [TopologicalSpace X] [SpectralSpace X] :
    T2Space (ConstructibleTop X) := by
  simp only [t2Space_iff, exists_and_left, instTopologicalSpace_eq_generateFrom_isOpen_isCompact]
  intro x y hxy
  obtain ⟨s, hs1, hs2⟩ := not_inseparable_iff_exists_open.1 <| (Decidable.not_imp_not.2 <|
    (t0Space_iff_inseparable X).1 inferInstance x y) hxy
  refine Or.elim hs2 ?_ ?_
  · rintro ⟨hxs, hys⟩
    obtain ⟨t, ht1, ht2, ht3⟩ := (IsTopologicalBasis.mem_nhds_iff <|
      (prespectralSpace_iff X).1 inferInstance).1 <| IsOpen.mem_nhds hs1 hxs
    refine ⟨t, isOpen_generateFrom_of_mem <| Set.mem_union_left _ ht1, ⟨tᶜ, ?_, ?_⟩⟩
    · exact isOpen_generateFrom_of_mem <| Set.mem_union_right _ ⟨t, ht1, rfl⟩
    · exact ⟨ht2, fun h => hys (ht3 h), Set.disjoint_compl_right_iff_subset.mpr fun _ h => h⟩
  · intro ⟨hys, hxs⟩
    obtain ⟨t, ⟨ht1, ht2⟩, ht3, ht4⟩ := (IsTopologicalBasis.mem_nhds_iff <|
      (prespectralSpace_iff X).1 inferInstance).1 <| IsOpen.mem_nhds hs1 hys
    refine ⟨tᶜ, isOpen_generateFrom_of_mem <| Set.mem_union_right _ ⟨t, ⟨ht1, ht2⟩, rfl⟩, ⟨t, ?_, ?_⟩⟩
    · exact isOpen_generateFrom_of_mem <| Set.mem_union_left _ ⟨ht1, ht2⟩
    · exact ⟨fun h => hxs (ht4 h), ht3, Set.disjoint_compl_left_iff_subset.mpr fun _ h => h⟩

instance compactSpace_of_spectralSpace (X : Type*) [TopologicalSpace X] [SpectralSpace X] :
    CompactSpace (ConstructibleTop X) := by
  rw [instTopologicalSpace_eq_generateFrom_isOpen_isCompact, ← @isCompact_univ_iff,
    @isCompact_iff_ultrafilter_le_nhds']
  intro F _
  by_contra h
  have h1 : ∀ x : X, ∃ t, x ∈ t ∧ t ∈ { s : Set X | IsOpen s ∧ IsCompact s } ∪
      compl '' { s : Set X | IsOpen s ∧ IsCompact s } ∧ t ∉ F := by
    simpa [nhds_generateFrom] using h
  obtain ⟨x, hx⟩ := @QuasiSober.sober X _ _ _
    (@Ultrafilter.sInter_isIrreducible_of_isClosed_mem X _ _ _ _ F)
    (isClosed_sInter fun _ h => h.1)
  have h2 : ∀ t ∈ { s | IsOpen s ∧ IsCompact s } ∪ compl '' { s | IsOpen s ∧ IsCompact s },
      x ∈ t → t ∈ F := by
    intro t ht hxt
    by_contra htF
    refine Or.elim ht ?_ ?_
    · rintro ⟨ht1, ht2⟩
      exact ((Set.sInter_subset_of_mem (Set.mem_sep (isClosed_compl_iff.mpr ht1)
        (Ultrafilter.compl_mem_iff_notMem.mpr htF))) (IsGenericPoint.mem hx)) hxt
    · rintro ⟨o, ⟨ho1, ho2⟩, hot⟩
      exact (hot ▸ hxt) ((singleton_closure_inter_open_nonempty_iff x ho1).1
        (Set.inter_comm _ _ ▸ hx ▸ Filter.inter_sInter_nonempty_of_isCompact_isClosed_mem ho2
          (Ultrafilter.compl_notMem_iff.mp (hot ▸ htF))))
  obtain ⟨t, hxt, ht, htF⟩ := h1 x
  exact htF (h2 t ht hxt)

end ConstructibleTop

end Theorem1

section CommentsBetweenThm1AndCorollaries

lemma TopologicalSpace.subbasis_iff_isTopologicalBasis_sInter
    {X : Type*} [T : TopologicalSpace X] (S : Set (Set X)) :
    T = generateFrom S ↔
    IsTopologicalBasis ((fun F => ⋂₀ F) '' { F : Set (Set X) | F.Finite ∧ F ⊆ S }) := by
  refine ⟨isTopologicalBasis_of_subbasis, fun h => h.eq_generateFrom ▸ eq_of_le_of_le ?_ ?_⟩
  · exact le_generateFrom fun s hsS =>
      isOpen_generateFrom_of_mem
        ⟨{s}, ⟨Set.finite_singleton s, Set.singleton_subset_iff.mpr hsS⟩, Set.sInter_singleton s⟩
  · exact le_generateFrom fun s ⟨F, ⟨hF, hFS⟩, hFs⟩ =>
      hFs ▸ @Set.Finite.isOpen_sInter _ (generateFrom S) _ hF fun t htF =>
        isOpen_generateFrom_of_mem (hFS htF)

lemma SpectralSpace.exists_of_isOpen_isCompact_isEmbedding {X Y : Type*}
    [TopologicalSpace X] [SpectralSpace X] [TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) {s : Set X} (hs1 : IsOpen s) (hs2 : IsCompact s) :
    ∃ o : Set Y, IsOpen o ∧ IsCompact o ∧ s = f ⁻¹' o := by
  let ι := Set.preimage f '' { s | IsOpen s ∧ IsCompact s }
  obtain ⟨S, hS, hsS⟩ := eq_finite_iUnion_of_isTopologicalBasis_of_isCompact_open (fun i : ι => i.1)
    (by simpa using hf.eq_induced ▸ PrespectralSpace.isTopologicalBasis.induced f) s hs2 hs1
  have : ∀ t ∈ ι, ∃ u : Set Y, IsOpen u ∧ IsCompact u ∧ t = f ⁻¹' u :=
    fun t ⟨u, ⟨hu1, hu2⟩, hfut⟩ => ⟨u, hu1, hu2, hfut.symm⟩
  choose! U hU1 hU2 hU3 using this
  exact ⟨⋃ t ∈ S, U t.1, isOpen_biUnion fun t htS => hU1 t t.2,
    Set.Finite.isCompact_biUnion hS fun t htS => hU2 t t.2,
    hsS ▸ Set.biUnion_eq_iUnion _ _ ▸ Set.biUnion_eq_iUnion _ _ ▸
      Set.preimage_iUnion (f := f) ▸ Set.iUnion_congr fun t => hU3 t.1 t.1.2⟩

lemma ConstructibleTop.instTopologicalSpace_eq_induced_of_isEmbedding_isSpectralMap
    {X Y : Type*} [TopologicalSpace X] [SpectralSpace X] [TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf1 : IsEmbedding f) (hf2 : IsSpectralMap f) :
    instTopologicalSpace X = induced f (instTopologicalSpace Y) := by
  rw [instTopologicalSpace_eq_generateFrom_isOpen_isCompact X,
    instTopologicalSpace_eq_generateFrom_isOpen_isCompact Y, induced_generateFrom_eq]
  refine eq_of_le_of_le (le_generateFrom fun s ⟨t, ht, hts⟩ => ?_) (le_generateFrom fun s hs => ?_)
  · refine Or.elim ht (fun ⟨ht1, ht2⟩ => ?_) (fun ⟨u, ⟨hu1, hu2⟩, hut⟩ => ?_)
    · exact hts ▸ generateFrom_isConstructible_eq_generateFrom_union_compl_image X ▸
        (TopologicalSpace.le_def.1 <| instTopologicalSpace_le X) _
          (IsOpen.preimage hf1.continuous ht1)
    · exact hts ▸ hut ▸ (isOpen_generateFrom_of_mem <|
        Or.intro_right _ ⟨f ⁻¹' u, ⟨IsOpen.preimage hf1.continuous hu1,
          hf2.isCompact_preimage_of_isOpen hu1 hu2⟩, rfl⟩)
  · refine isOpen_generateFrom_of_mem <| Or.elim hs ?_ ?_
    · intro ⟨hs1, hs2⟩
      obtain ⟨o, ho1, ho2, hsfo⟩ := SpectralSpace.exists_of_isOpen_isCompact_isEmbedding hf1 hs1 hs2
      exact ⟨o, Or.intro_left _ ⟨ho1, ho2⟩, hsfo.symm⟩
    · intro ⟨o, ⟨ho1, ho2⟩, hos⟩
      obtain ⟨t, ht1, ht2, hoft⟩ := SpectralSpace.exists_of_isOpen_isCompact_isEmbedding hf1 ho1 ho2
      exact ⟨tᶜ, Or.intro_right _ ⟨t, ⟨ht1, ht2⟩, rfl⟩, Set.preimage_compl.symm ▸ hoft ▸ hos⟩

lemma IsSpectralMap.continuous_of_spectralSpace_constructibleTop {X Y : Type*}
    [TopologicalSpace X] [SpectralSpace X] [TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf : IsSpectralMap f) :
    Continuous (X := ConstructibleTop X) (Y := ConstructibleTop Y) f := by
  rw [ConstructibleTop.instTopologicalSpace_eq_generateFrom_isOpen_isCompact X,
    ConstructibleTop.instTopologicalSpace_eq_generateFrom_isOpen_isCompact Y]
  refine continuous_generateFrom_iff.2 ?_
  · intro s hs
    refine Or.elim hs ?_ ?_
    · intro ⟨hs1, hs2⟩
      exact isOpen_generateFrom_of_mem <| Or.intro_left _ ⟨hf.1.isOpen_preimage s hs1, hf.2 hs1 hs2⟩
    · intro ⟨o, ⟨ho1, ho2⟩, hos⟩
      exact isOpen_generateFrom_of_mem <| Or.intro_right _ <| hos ▸
        ⟨f ⁻¹' o, ⟨hf.1.isOpen_preimage o ho1, hf.2 ho1 ho2⟩, rfl⟩

lemma IsCompact.of_le_of_isCompact {X : Type*} [S : TopologicalSpace X] [T : TopologicalSpace X]
    (hST : S ≤ T) {s : Set X} (hs : @IsCompact _ S s) : @IsCompact _ T s := by
  refine isCompact_iff_finite_subcover.2 ?_
  · intro ι U hιU hsU
    exact (@isCompact_iff_finite_subcover X S s).1 hs U (fun i => hST (U i) (hιU i)) hsU

lemma IsSpectralMap.of_continuous_of_continuous_constructibleTop {X Y : Type*}
    [TopologicalSpace X] [SpectralSpace X] [TopologicalSpace Y] [SpectralSpace Y] {f : X → Y}
    (hf1 : Continuous f) (hf2 : Continuous (X := ConstructibleTop X) (Y := ConstructibleTop Y) f) :
    IsSpectralMap f := by
  refine ⟨hf1, ?_⟩
  · intro s hs1 hs2
    have : IsCompact (X := ConstructibleTop X) (f ⁻¹' s) := by
      haveI := ConstructibleTop.compactSpace_of_spectralSpace X
      refine IsClosed.isCompact <| IsClosed.preimage (X := ConstructibleTop X)
        (Y := ConstructibleTop Y) hf2 ?_
      · rw [ConstructibleTop.instTopologicalSpace_eq_generateFrom_isOpen_isCompact]
        exact (@isOpen_compl_iff _ _ (generateFrom _)).1 <| isOpen_generateFrom_of_mem <|
          Or.intro_right _ ⟨s, ⟨hs1, hs2⟩, rfl⟩
    exact IsCompact.of_le_of_isCompact (S := ConstructibleTop.instTopologicalSpace X)
      (T := (inferInstance : TopologicalSpace X)) (ConstructibleTop.instTopologicalSpace_le X) this

lemma isSpectralMap_iff_continuous_and_continuous_constructibleTop {X Y : Type*}
    [TopologicalSpace X] [SpectralSpace X] [TopologicalSpace Y] [SpectralSpace Y] (f : X → Y) :
    IsSpectralMap f ↔
    Continuous f ∧ Continuous (X := ConstructibleTop X) (Y := ConstructibleTop Y) f :=
  ⟨fun hf => ⟨hf.toContinuous, hf.continuous_of_spectralSpace_constructibleTop⟩,
    fun ⟨hf1, hf2⟩ => IsSpectralMap.of_continuous_of_continuous_constructibleTop hf1 hf2⟩

lemma IsSpectralMap.isClosed_range {X Y : Type*}
    [TopologicalSpace X] [SpectralSpace X] [TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf : IsSpectralMap f) :
    IsClosed (X := ConstructibleTop Y) (Set.range f) :=
  IsCompact.isClosed <| isCompact_range (X := ConstructibleTop X) (Y := ConstructibleTop Y) <|
    IsSpectralMap.continuous_of_spectralSpace_constructibleTop hf

lemma compactSpace_of_isEmbedding_of_isClosed_constructibleTop_range
    {X Y : Type*} [TopologicalSpace X] [T : TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) (hfX : IsClosed (X := ConstructibleTop Y) (Set.range f)) :
    CompactSpace X :=
  ⟨(IsEmbedding.isCompact_iff hf).2
    (Set.image_univ ▸ IsCompact.of_le_of_isCompact (S := ConstructibleTop.instTopologicalSpace Y)
      (T := T) (ConstructibleTop.instTopologicalSpace_le Y) (IsClosed.isCompact hfX))⟩

lemma quasiSober_of_isEmbedding_of_isClosed_constructibleTop_range
    {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [SpectralSpace Y]
    {f : X → Y} (hf : IsEmbedding f) (hfX : IsClosed (X := ConstructibleTop Y) (Set.range f)) :
    QuasiSober X := by
  constructor
  · intro S hS1 hS2
    sorry

-- lemma isSpectralMap_iff_isClosed_constructibleTop_range {X Y : Type*}
--     [S : TopologicalSpace X] [SpectralSpace X] [T : TopologicalSpace Y] [SpectralSpace Y]
--     {f : X → Y} (hf : IsEmbedding f) :
--     IsSpectralMap f ↔ IsClosed (X := ConstructibleTop Y) (Set.range f) := by
--   refine ⟨fun h => h.isClosed_range, fun h => ⟨hf.continuous, fun s hs1 hs2 => ?_⟩⟩
--   · have h1 : IsClosed (X := ConstructibleTop Y) s :=
--       ⟨ConstructibleTop.instTopologicalSpace_eq_generateFrom_isOpen_isCompact Y ▸
--         isOpen_generateFrom_of_mem <| Or.intro_right _ ⟨s, ⟨hs1, hs2⟩, rfl⟩⟩
--     have h2 : IsCompact (s ∩ Set.range f) :=
--       ((IsClosed.isCompact h).inter_left h1).of_le_of_isCompact
--         (S := ConstructibleTop.instTopologicalSpace Y) (T := T)
--           (ConstructibleTop.instTopologicalSpace_le Y)
--     exact Set.preimage_inter_range.symm ▸ hf.isCompact_iff.2
--       ((Set.image_preimage_eq_of_subset Set.inter_subset_right).symm ▸ h2)

end CommentsBetweenThm1AndCorollaries

section Corollaries

lemma Set.Finite.sInter_mem_of_finiteInter {α : Type*} {S : Set (Set α)}
    (hS : FiniteInter S) {F : Set (Set α)} (hF : F.Finite) :
    F ⊆ S → ⋂₀ F ∈ S := fun hFS => by
  simpa only [Set.Finite.coe_toFinset] using FiniteInter.finiteInter_mem hS hF.toFinset
    (fun f hfF => hFS ((Set.Finite.mem_toFinset hF).1 hfF))

lemma Set.Finite.sInter_ne_empty_of_finiteInter_finiteInter_of_subset_union
    {α : Type*} {S T U : Set (Set α)} (hS : FiniteInter S) (hT : FiniteInter T)
    (hST : ∀ s ∈ S, ∀ t ∈ T, s ∩ t ≠ ∅) (hU : U.Finite) (hUST : U ⊆ S ∪ T) :
    ⋂₀ U ≠ ∅ :=
  (Set.inter_union_distrib_left U S T ▸ Set.left_eq_inter.2 hUST) ▸
    Set.sInter_union _ _ ▸ hST _
      (Set.Finite.sInter_mem_of_finiteInter hS (Set.Finite.inter_of_left hU S)
        Set.inter_subset_right) _
      (Set.Finite.sInter_mem_of_finiteInter hT (Set.Finite.inter_of_left hU T)
        Set.inter_subset_right)

lemma SpectralSpace.mem_patch_closure_iff_mem_pt_closure {X : Type*} [TopologicalSpace X]
    [SpectralSpace X] {Y : Set X} (hY : IsClosed (X := ConstructibleTop X) Y) (x : X) :
    x ∈ closure Y ↔ ∃ y ∈ Y, x ∈ closure {y} := by
  refine ⟨fun hxY => ?_, fun ⟨y, hyY, hxy⟩ => closure_mono (Set.singleton_subset_iff.2 hyY) hxy⟩
  · have : (Y ∩ ⋂₀ { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s }).Nonempty := by
      by_contra h
      let ι := { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s }
      let t : ι → Set X := fun i => i.1
      have hιt : ∀ i : ι, IsClosed (X := ConstructibleTop X) (t i) := fun ⟨i, hiι⟩ =>
        ⟨ConstructibleTop.instTopologicalSpace_eq_generateFrom_isOpen_isCompact X ▸
          isOpen_generateFrom_of_mem <| Or.intro_right _ ⟨i, ⟨hiι.1, hiι.2.1⟩, rfl⟩⟩
      have := (isCompact_iff_finite_subfamily_closed (X := ConstructibleTop X)).1
        (IsClosed.isCompact hY) t hιt
      simp only [t, ← Set.sInter_eq_iInter] at this
      obtain ⟨U', hYU'⟩ := this (Set.not_nonempty_iff_eq_empty.1 h)
      let U : Set (Set X) := Subtype.val '' U'.toSet
      have hU1 : U.Finite := U.toFinite
      have hU2 : U ⊆ { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } :=
        Subtype.coe_image_subset { s | IsOpen s ∧ IsCompact s ∧ x ∈ s } U'
      have hx : FiniteInter { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } :=
        ⟨⟨isOpen_univ, CompactSpace.isCompact_univ, trivial⟩,
          fun s ⟨hs1, hs2, hxs⟩ t ⟨ht1, ht2, hxt⟩ =>
          ⟨IsOpen.inter hs1 ht1, IsCompact.inter_of_isOpen hs2 ht2 hs1 ht1, Set.mem_inter hxs hxt⟩⟩
      obtain ⟨hU3, hU4, hxU⟩ := Set.Finite.sInter_mem_of_finiteInter hx hU1 hU2
      exact Set.nonempty_iff_ne_empty.1 (Set.inter_comm _ _ ▸
        ((mem_closure_iff PrespectralSpace.isTopologicalBasis).1 hxY) (⋂₀ U) ⟨hU3, hU4⟩ hxU)
        ((Set.sInter_eq_biInter ▸ Eq.symm Set.biInter_image) ▸ hYU')
    obtain ⟨y, hyY, hyx⟩ := this
    exact ⟨y, hyY, (mem_closure_iff PrespectralSpace.isTopologicalBasis).2
      fun s ⟨hs1, hs2⟩ hxs => Set.inter_singleton_nonempty.2 (hyx s ⟨hs1, hs2, hxs⟩)⟩

lemma SpectralSpace.exist_open_disjoint_or_mem_pt_closure
    {X : Type*} [TopologicalSpace X] [SpectralSpace X] (x y : X) :
    (∃ O1 O2, IsOpen O1 ∧ IsOpen O2 ∧ x ∈ O1 ∧ y ∈ O2 ∧ Disjoint O1 O2) ∨
    (∃ z, x ∈ closure {z} ∧ y ∈ closure {z}) := by
  refine Decidable.or_iff_not_imp_left.2 ?_
  · simp only [exists_and_left, not_exists, not_and]
    intro h
    have : (⋂₀ ({ s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } ∪
        { s | IsOpen s ∧ IsCompact s ∧ y ∈ s })).Nonempty := by
      by_contra h'
      let ι := { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } ∪
        { s : Set X | IsOpen s ∧ IsCompact s ∧ y ∈ s }
      let t : ι → Set X := fun i => i.1
      have hιt : ∀ i : ι, IsClosed (X := ConstructibleTop X) (t i) := fun ⟨i, hiι⟩ =>
        ⟨ConstructibleTop.instTopologicalSpace_eq_generateFrom_isOpen_isCompact X ▸
          isOpen_generateFrom_of_mem <| Or.elim hiι
            (fun ⟨hi1, hi2, _⟩ => Or.intro_right _ ⟨i, ⟨hi1, hi2⟩, rfl⟩)
            (fun ⟨hi1, hi2, _⟩ => Or.intro_right _ ⟨i, ⟨hi1, hi2⟩, rfl⟩)⟩
      have := (isCompact_iff_finite_subfamily_closed (X := ConstructibleTop X)).1
        CompactSpace.isCompact_univ t hιt
      simp only [Set.univ_inter, t, ← Set.sInter_eq_iInter] at this
      obtain ⟨U', hU'⟩ := this (Set.not_nonempty_iff_eq_empty.1 h')
      let U : Set (Set X) := Subtype.val '' U'.toSet
      have hU1 : U.Finite := U.toFinite
      have hU2 : U ⊆ { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } ∪
          { s | IsOpen s ∧ IsCompact s ∧ y ∈ s } :=
        Subtype.coe_image_subset ({ s | IsOpen s ∧ IsCompact s ∧ x ∈ s } ∪
          { s | IsOpen s ∧ IsCompact s ∧ y ∈ s }) U'
      have hx : FiniteInter { s : Set X | IsOpen s ∧ IsCompact s ∧ x ∈ s } :=
        ⟨⟨isOpen_univ, CompactSpace.isCompact_univ, trivial⟩,
          fun s ⟨hs1, hs2, hxs⟩ t ⟨ht1, ht2, hxt⟩ =>
          ⟨IsOpen.inter hs1 ht1, IsCompact.inter_of_isOpen hs2 ht2 hs1 ht1, Set.mem_inter hxs hxt⟩⟩
      have hy : FiniteInter { s : Set X | IsOpen s ∧ IsCompact s ∧ y ∈ s } :=
        ⟨⟨isOpen_univ, CompactSpace.isCompact_univ, trivial⟩,
          fun s ⟨hs1, hs2, hys⟩ t ⟨ht1, ht2, hyt⟩ =>
          ⟨IsOpen.inter hs1 ht1, IsCompact.inter_of_isOpen hs2 ht2 hs1 ht1, Set.mem_inter hys hyt⟩⟩
      exact Set.Finite.sInter_ne_empty_of_finiteInter_finiteInter_of_subset_union hx hy
        (fun s ⟨hs1, hs2, hxs⟩ t ⟨ht1, ht2, hyt⟩ => Set.nonempty_iff_ne_empty.1
          (Set.not_disjoint_iff_nonempty_inter.1 (h s hs1 t ht1 hxs hyt)))
        hU1 hU2 ((Set.sInter_eq_biInter ▸ Eq.symm Set.biInter_image) ▸ hU')
    obtain ⟨z, hzx, hzy⟩ := Set.sInter_union _ _ ▸ this
    refine ⟨z, ?_, ?_⟩
    · exact (mem_closure_iff PrespectralSpace.isTopologicalBasis).2
        fun s ⟨hs1, hs2⟩ hxs => Set.inter_singleton_nonempty.2 (hzx s ⟨hs1, hs2, hxs⟩)
    · exact (mem_closure_iff PrespectralSpace.isTopologicalBasis).2
        fun s ⟨hs1, hs2⟩ hys => Set.inter_singleton_nonempty.2 (hzy s ⟨hs1, hs2, hys⟩)

end Corollaries
